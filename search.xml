<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[find]]></title>
      <url>/2017/10/16/find/</url>
      <content type="html"><![CDATA[<h1 id="find命令的使用"><a href="#find命令的使用" class="headerlink" title="find命令的使用"></a>find命令的使用</h1><h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><p>find是在指定目录下查找文件。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find pathname  -options [-print -exec -ok ...]</span><br></pre></td></tr></table></figure>
<h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- pathname: find命令所查找的目录路径。</span><br><span class="line">- -print： find命令将匹配的文件输出到标准输出。</span><br><span class="line">- -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应的命令形式为 &apos;command&apos; &#123; &#125; ;，注意&#123; &#125;和；之间的空格。</span><br><span class="line">- -ok： 和-exec的作用相同，只不过以一种更安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</span><br></pre></td></tr></table></figure>
<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><h3 id="name"><a href="#name" class="headerlink" title="-name"></a>-name</h3><p>按照文件名查找文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &quot;*.c&quot;  #查找本目录下，所有以.c结尾的文件</span><br></pre></td></tr></table></figure>
<h3 id="perm"><a href="#perm" class="headerlink" title="-perm"></a>-perm</h3><p>按照文件权限查找文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -perm 777</span><br></pre></td></tr></table></figure>
<h3 id="mtime-n-n"><a href="#mtime-n-n" class="headerlink" title="-mtime -n +n"></a>-mtime -n +n</h3><p>按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-mtime选项类似。</p>
<p>注意：下面是几个按照时间来查找文件的参数含义总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-amin n</span><br><span class="line"></span><br><span class="line">查找系统中最后N分钟访问的文件</span><br><span class="line"></span><br><span class="line">-atime n</span><br><span class="line"></span><br><span class="line">查找系统中最后n*24小时访问的文件</span><br><span class="line"></span><br><span class="line">-cmin n</span><br><span class="line"></span><br><span class="line">查找系统中最后N分钟被改变文件状态的文件</span><br><span class="line"></span><br><span class="line">-ctime n</span><br><span class="line"></span><br><span class="line">查找系统中最后n*24小时被改变文件状态的文件</span><br><span class="line"></span><br><span class="line">-mmin n</span><br><span class="line"></span><br><span class="line">查找系统中最后N分钟被改变文件数据的文件</span><br><span class="line"></span><br><span class="line">-mtime n</span><br><span class="line"></span><br><span class="line">查找系统中最后n*24小时被改变文件数据的文件</span><br></pre></td></tr></table></figure>
<h3 id="type"><a href="#type" class="headerlink" title="-type"></a>-type</h3><p>查找某一类型的文件，诸如：</p>
<p>b - 块设备文件。</p>
<p>d - 目录。</p>
<p>c - 字符设备文件。</p>
<p>p - 管道文件。</p>
<p>l - 符号链接文件。</p>
<p>f - 普通文件。</p>
<h3 id="newer-file1-file2"><a href="#newer-file1-file2" class="headerlink" title="-newer file1 ! file2"></a>-newer file1 ! file2</h3><p>查找更改时间比文件file1新但比文件file2旧的文件。</p>
<h2 id="使用exec或ok执行shell命令"><a href="#使用exec或ok执行shell命令" class="headerlink" title="使用exec或ok执行shell命令"></a>使用exec或ok执行shell命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find  -type f -exec ls -l &#123; &#125; ; #查看当前目录下的普通文件，并且对那些文件执行 ls -l</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.conf&quot; -mtime +5 -ok rm &#123; &#125; ;</span><br><span class="line">#删除本目录下的conf后缀的文件并且该文件在5天前被修改。ok会先询问用户是否确定要删除文件</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux命令大全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[umask]]></title>
      <url>/2017/10/16/umask/</url>
      <content type="html"><![CDATA[<h1 id="umask命令的使用"><a href="#umask命令的使用" class="headerlink" title="umask命令的使用"></a>umask命令的使用</h1><h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><p>umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">umask [-S] [权限掩码]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-S 　以文字的方式来表示权限掩码。（r、w、x）</span><br></pre></td></tr></table></figure>
<p>注意：如果umask后面不带任何内容，则是输出当前系统的权限掩码。</p>
<h2 id="命令的使用示例"><a href="#命令的使用示例" class="headerlink" title="命令的使用示例"></a>命令的使用示例</h2><h3 id="查看权限掩码"><a href="#查看权限掩码" class="headerlink" title="查看权限掩码"></a>查看权限掩码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask   #查看当前系统的掩码</span><br></pre></td></tr></table></figure>
<h3 id="修改权限掩码"><a href="#修改权限掩码" class="headerlink" title="修改权限掩码"></a>修改权限掩码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask 002</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux命令大全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++运算符重载]]></title>
      <url>/2017/10/08/c++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      <content type="html"><![CDATA[<h1 id="运算符重载遵循如下规则"><a href="#运算符重载遵循如下规则" class="headerlink" title="运算符重载遵循如下规则"></a>运算符重载遵循如下规则</h1><ul>
<li>除类属关系运算符”.”、成员指针运算符”.*”、作用域运算符”::”、sizeof运算符和三目运算符”?:”以外,其他运算符都可以重载。</li>
<li>重载之后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。</li>
</ul>
<h1 id="运算符重载的方式"><a href="#运算符重载的方式" class="headerlink" title="运算符重载的方式"></a>运算符重载的方式</h1><p>重载为类的成员函数和重载为类的非成员函数。非成员函数通常是友元。</p>
<h1 id="成员函数运算符"><a href="#成员函数运算符" class="headerlink" title="成员函数运算符"></a>成员函数运算符</h1><h2 id="语法形式"><a href="#语法形式" class="headerlink" title="语法形式"></a>语法形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;函数类型&gt; operator &lt;运算符&gt;（&lt;参数列表&gt;）</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	int value;</span><br><span class="line">public:</span><br><span class="line">	A(int v = 0):value(v)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	A  operator + (const A &amp; right)</span><br><span class="line">	&#123;</span><br><span class="line">		return A(value + right.value);</span><br><span class="line">	&#125;</span><br><span class="line">	void print()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a(1);</span><br><span class="line">	A b(2);</span><br><span class="line">	A c = a + b;</span><br><span class="line">	c.print();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="友元函数运算符"><a href="#友元函数运算符" class="headerlink" title="友元函数运算符"></a>友元函数运算符</h1><h2 id="语法形式-1"><a href="#语法形式-1" class="headerlink" title="语法形式"></a>语法形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">friend &lt;函数类型&gt; operator &lt;运算符&gt;(&lt;参数列表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	int value;</span><br><span class="line">public:</span><br><span class="line">	A(int v = 0):value(v)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	friend A  operator + (const A &amp; left, const A &amp; right);</span><br><span class="line">	void print()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A operator + (const A &amp; left, const A &amp; right)</span><br><span class="line">&#123;</span><br><span class="line">	return A(left.value + right.value);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a(1);</span><br><span class="line">	A b(2);</span><br><span class="line">	A c = a + b;</span><br><span class="line">	c.print();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>一般双目运算符重载用友元实现，但是以下一些双目运算符不能重载为类的友元函数：=、()、[]、-&gt;</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>c++ 函数符号重载 返回类型是否为引用？</p>
<p>参考博客：<a href="http://blog.csdn.net/qq_19175749/article/details/49739165" target="_blank" rel="noopener">c++ 函数符号重载 返回类型是否为引用问题 剖析</a></p>
]]></content>
      
        
        <tags>
            
            <tag> c++提高 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10月8日面试题总结]]></title>
      <url>/2017/10/08/10%E6%9C%888%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="数组名的知识总结"><a href="#数组名的知识总结" class="headerlink" title="数组名的知识总结"></a>数组名的知识总结</h1><h2 id="数组名的本质"><a href="#数组名的本质" class="headerlink" title="数组名的本质"></a>数组名的本质</h2><p>数组名可以看成是指向这个数组的首地址的指针，不过它是当做一个地址常量使用，同时，它还可以表示这个数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[5];</span><br><span class="line"></span><br><span class="line">*a++     //这个是错误的，因为a是地址常量</span><br><span class="line"></span><br><span class="line">sizeof(a) = 4 * 5 = 20；</span><br></pre></td></tr></table></figure>
<h2 id="a和-amp-a的区别"><a href="#a和-amp-a的区别" class="headerlink" title="a和&amp;a的区别"></a>a和&amp;a的区别</h2><p>&amp;a是整个数组的首地址，a是数组首元素的首地址，其值相同，但是意义不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[2] = &#123;1,2&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt;endl;</span><br><span class="line">	//相当于：a + 1 * sizeof(int)</span><br><span class="line">	cout &lt;&lt; a + 1&lt;&lt; endl;</span><br><span class="line">	//相当于：a + 2 * sizeof(int),得到的值为最后一个元素的下一个地址</span><br><span class="line">	cout &lt;&lt; &amp;a + 1 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/**********************</span><br><span class="line">0x7ffe8319e670</span><br><span class="line">0x7ffe8319e670</span><br><span class="line">0x7ffe8319e674</span><br><span class="line">0x7ffe8319e678</span><br><span class="line">***********************/</span><br></pre></td></tr></table></figure></p>
<h2 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //数组的定义并赋值，不知道这个，建议回家</span><br><span class="line">    int a[5]=&#123;1,2,3,4,5&#125;;</span><br><span class="line">    //这时这个，ptr1保存的是最后一个元素的下一个地址</span><br><span class="line">    int *ptr1=(int *)(&amp;a+1);</span><br><span class="line">    //(int)a,是不是把数组的地址强转成整型，这样+1,只是在个这个地址值加了一</span><br><span class="line">    //个1。还记得a+1吗，由于a是数组的名首地址，a+1的值是多少？你懂的。</span><br><span class="line">    int *ptr2=(int *)((int )a+1);</span><br><span class="line">    //ptr1[-1],下表是-1?哇塞，不可能吧?笨笨都是这样想，但我们是开发人员，</span><br><span class="line">    //我们知道ptr1[-1],其实可以看成*(ptr1 -1)。还记得ptr1保存的值吗？知道ptr1[-1]的值吧.</span><br><span class="line">    printf(&quot;%x,%x&quot;,ptr1[-1],*ptr2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/**********************</span><br><span class="line">5，,2000000</span><br><span class="line">***********************/</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++柔性数组]]></title>
      <url>/2017/09/26/c++%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h1 id="背景讨论"><a href="#背景讨论" class="headerlink" title="背景讨论"></a>背景讨论</h1><p>在日常编程中，可能需要在结构体中存放一个长度动态变化的变量（这里统一以字符变量为例子），一般做法是在结构体中定义一个字符指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct test    </span><br><span class="line">&#123;    </span><br><span class="line">       int a;    </span><br><span class="line">       double b;    </span><br><span class="line">       char *p;    </span><br><span class="line">&#125;test;</span><br></pre></td></tr></table></figure>
<p>首先了，这种做法造成了字符串p的存储空间和结构体是分离，如果想把它们连在一起，可以通过如下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a[] = &quot;Hello\n&quot;;</span><br><span class="line">test * t = (test *)malloc(sizeof(test) + strlen(a) + 1);</span><br><span class="line">strcpy(t + 1,a);</span><br></pre></td></tr></table></figure>
<p>通过上述代码的定义，(char *)(t + 1)就是字符串“Hello\n”的首地址了。但是这个时候p就变的有点多余并且还要占用4个字节的空间。正是出于这样的一个考虑，c99加入了柔性数组的这样一个属性。</p>
<h1 id="柔性数组的介绍"><a href="#柔性数组的介绍" class="headerlink" title="柔性数组的介绍"></a>柔性数组的介绍</h1><p>c99中，结构体的最后一个字段允许是一个未知大小的数组，这个数组就叫柔性数组。结构体的柔性数组前必须包含一个其他成员。</p>
<p>柔性数组成员只作为一个符号地址存在，而且必须是结构体的最后一个成员，sizeof返回的这种结构大小不包括柔性数组的内存。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct test  </span><br><span class="line">&#123;  </span><br><span class="line">    int a;  </span><br><span class="line">    double b;  </span><br><span class="line">    char c[]; //或者声明为：char c[0]，但是这种形式，有些编译器会报错无法编译。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct test</span><br><span class="line">&#123;</span><br><span class="line">	int a;</span><br><span class="line">	double b;</span><br><span class="line">	char c[0];</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;test的大小：&quot;&lt;&lt;sizeof(test) &lt;&lt; endl;</span><br><span class="line">	test * t = (test * )malloc(sizeof(test) + 10 * sizeof(char));</span><br><span class="line">	strcpy(t-&gt;c,&quot;Hello&quot;);</span><br><span class="line">	cout &lt;&lt; t-&gt;c &lt;&lt; endl;</span><br><span class="line">	free(t);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test的大小：16</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p>所以从输出结果可以知道，首先，c不占结构体的内存，然后t-&gt;c就是“hello world”的首地址，不需要再使用( char * )( t + 1 )这么复杂代码了.</p>
]]></content>
      
        
        <tags>
            
            <tag> c++提高 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[9月26日笔试总结]]></title>
      <url>/2017/09/26/9%E6%9C%8826%E6%97%A5%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="“重载”和“重写的区别”"><a href="#“重载”和“重写的区别”" class="headerlink" title="“重载”和“重写的区别”"></a>“重载”和“重写的区别”</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>指函数名相同，但是它的参数表列个数或顺序，类型不同。但是不能靠返回类型来判断。</p>
<ul>
<li>相同的范围（在同一个作用域中） ；</li>
<li>函数名字相同；</li>
<li>参数不同；</li>
<li>virtual 关键字可有可无。</li>
<li>返回值可以不同；</li>
</ul>
<h2 id="重写（也称为覆盖-override）"><a href="#重写（也称为覆盖-override）" class="headerlink" title="重写（也称为覆盖 override）"></a>重写（也称为覆盖 override）</h2><p>是指派生类重新定义基类的虚函数，特征是：</p>
<ul>
<li>不在同一个作用域（分别位于派生类与基类） ；</li>
<li>函数名字相同；</li>
<li>参数相同；</li>
<li>基类函数必须有 virtual 关键字，不能有 static 。</li>
<li>返回值相同（或是协变），否则报错；</li>
<li>重写函数的访问修饰符可以不同。尽管 virtual 是 private 的，派生类中重写改写为 public,protected 也是可以的</li>
</ul>
<p>注意：若已包含标准库头文件及相关命名空间，则系统不允许用户重写标准库函数</p>
<h1 id="include-和-include”filename-h”的区别"><a href="#include-和-include”filename-h”的区别" class="headerlink" title="#include 和 #include”filename.h”的区别"></a>#include<fliename.h> 和 #include”filename.h”的区别</fliename.h></h1><p>#include<filename.h>系统检索头文件时 会先从系统文件里开始找<br> ，再找其他地方。用于系统文件较快。</filename.h></p>
<p>#include”filename.h”系统检索头文件时先从程序所处目录开始查找。<br>用于自定义文件较快。</p>
<h1 id="参数传递的问题"><a href="#参数传递的问题" class="headerlink" title="参数传递的问题"></a>参数传递的问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int f(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    return  f(printf(&quot;a&quot;),printf(&quot;b&quot;),printf(&quot;c&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑如下两个问题：</p>
<ul>
<li>printf的返回值</li>
<li>参数入栈的顺序</li>
</ul>
<h1 id="printf的返回值"><a href="#printf的返回值" class="headerlink" title="printf的返回值"></a>printf的返回值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//函数原型，因此其返回值为int型数据</span><br><span class="line">int _Cdecl printf (const char *format, ...);</span><br></pre></td></tr></table></figure>
<h2 id="函数实参传递的顺序"><a href="#函数实参传递的顺序" class="headerlink" title="函数实参传递的顺序"></a>函数实参传递的顺序</h2><ul>
<li>在x86架构（Linux或Unix系统）上，函数的参数是通过栈传递的。因此参数从右往左入栈顺序是：printf(“c”)，printf(“b”)，printf(“a”)。依次计算出结果：cba</li>
<li>在x86_64架构（Linux或Unix系统）上，函数的前6个参数是通过寄存器传递的，超出6个的部分（如第7个参数，第8个参数等等）通过栈传递。因此参数进寄存器顺序是：printf(“a”)，printf(“b”)，printf(“c”)。依次计算出结果：abc</li>
</ul>
<p>补充：</p>
<ul>
<li>模板的使用实际上是将类模板实例化成一个类。</li>
<li>两个相同作用域内的函数 如果除了返回值类型外 的函数要素都相同 那么编译器会报重定义错误</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[9月25日笔试总结]]></title>
      <url>/2017/09/25/9%E6%9C%8825%E6%97%A5%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="派生类访问权限的问题"><a href="#派生类访问权限的问题" class="headerlink" title="派生类访问权限的问题"></a>派生类访问权限的问题</h1><p><img src="http://img.blog.csdn.net/20161015211225613" alt="image"></p>
<h1 id="模板函数的定义和调用"><a href="#模板函数的定义和调用" class="headerlink" title="模板函数的定义和调用"></a>模板函数的定义和调用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T add(T a,T b)</span><br><span class="line">&#123;</span><br><span class="line"> T c;</span><br><span class="line"> c=a+b;</span><br><span class="line"> return c;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">add(2,3);</span><br><span class="line">add(2.0,3.0);</span><br><span class="line">add(2,2.0);        ///  会报错</span><br><span class="line">add&lt;float&gt;(2,2.0); ///  正确</span><br></pre></td></tr></table></figure>
<h1 id="引用的问题"><a href="#引用的问题" class="headerlink" title="引用的问题"></a>引用的问题</h1><p> 非常量引用必须是左值。</p>
<p>左值和右值都是针对表达式而言的，左值是指表达式结束后依然存在的持久对象，右值是指表达式结束时就不再存在的临时对象。<br>在标准C++语言中，临时量（术语为右值，因其出现在赋值表达式的右边）可以被传给函数，但只能被接受为const &amp;类型。</p>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++成员变量、构造函数初始化问题]]></title>
      <url>/2017/09/24/c++%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="c-成员变量初始化"><a href="#c-成员变量初始化" class="headerlink" title="c++成员变量初始化"></a>c++成员变量初始化</h1><h2 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h2><p>在构造函数中进行赋值，如果考虑效率的话，在构造函数的初始化列表中进行赋值。</p>
<h2 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h2><p>static变量属于类所有，不属于任何一个对象。在类中，static成员函数也属于类所有，所以这个函数不接受this指针，因此只能访问static成员变量。</p>
<h2 id="const常量变量"><a href="#const常量变量" class="headerlink" title="const常量变量"></a>const常量变量</h2><p>const常量需要在声明的时候即初始化。因此需要在变量创建的时候进行初始化。一般采用在构造函数的初始化列表中对const变量进行初始化。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用型变量和const变量类似。需要在创建的时候即进行初始化。也是在初始化列表中进行。但需要注意用Reference类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">    int &amp; b;</span><br><span class="line">public:</span><br><span class="line">    ///必须使用初始化列表</span><br><span class="line">    A():b(&amp;a)&#123;&#125;</span><br><span class="line">    A(int &amp; c):b(c)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="const-static-integral-变量"><a href="#const-static-integral-变量" class="headerlink" title="const static integral 变量"></a>const static integral 变量</h2><p>对于既是const又是static 而且还是整形变量，可以直接在类的定义中初始化，但是初始化值必须是常量表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">  const static int q = 0;  ///可以直接在初始化</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：<br>C++11的基本思想是，允许非静态（non-static）数据成员在其声明处（在其所属类内部）进行初始化。这样，在运行过程中，需要初始值时构造函数可以使用这个初始值。</p>
<h1 id="构造函数的调用顺序"><a href="#构造函数的调用顺序" class="headerlink" title="构造函数的调用顺序"></a>构造函数的调用顺序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先，任何虚拟基类的构造函数按照它们被继承的顺序构造；</span><br><span class="line">其次，任何非虚拟基类的构造函数按照它们被继承的顺序构造；</span><br><span class="line">然后，任何成员对象的构造函数按照它们声明的顺序调用；</span><br><span class="line">最后，是本类的构造函数</span><br><span class="line"></span><br><span class="line">析构函数的为“逆构造函数”，其析构顺序和构造函数相反</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class OBJ1&#123;</span><br><span class="line">   public:</span><br><span class="line">      OBJ1()&#123; cout&lt;&lt;&quot;OBJ1\n&quot;; &#125;</span><br><span class="line">	  ~OBJ1()&#123; cout&lt;&lt;&quot;~OBJ1\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class OBJ2&#123;</span><br><span class="line">   public:</span><br><span class="line">     OBJ2()&#123; cout&lt;&lt;&quot;OBJ2\n&quot;;&#125;</span><br><span class="line">	 ~OBJ2()&#123; cout&lt;&lt;&quot;~OBJ2\n&quot;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Base1&#123;</span><br><span class="line">   public:</span><br><span class="line">     Base1()&#123; cout&lt;&lt;&quot;Base1\n&quot;;&#125;</span><br><span class="line">	 ~Base1()&#123; cout&lt;&lt;&quot;~Base1\n&quot;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Base2&#123;</span><br><span class="line">   public:</span><br><span class="line">     Base2()&#123; cout &lt;&lt;&quot;Base2\n&quot;; &#125;</span><br><span class="line">	 ~Base2()&#123; cout &lt;&lt;&quot;~Base2\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Base3&#123;</span><br><span class="line">  public:</span><br><span class="line">    Base3()&#123; cout &lt;&lt;&quot;Base3\n&quot;; &#125;</span><br><span class="line">	~Base3()&#123; cout &lt;&lt;&quot;~Base3\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Base4&#123;</span><br><span class="line">  public:</span><br><span class="line">    Base4()&#123; cout &lt;&lt;&quot;Base4\n&quot;; &#125;</span><br><span class="line">	~Base4()&#123; cout &lt;&lt;&quot;~Base4\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derived :public Base1, virtual public Base2,</span><br><span class="line">              public Base3, virtual public Base4//继承顺序</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      Derived() :Base4(), Base3(), Base2(),Base1(), obj2(), obj1()&#123;//初始化列表</span><br><span class="line">        cout &lt;&lt;&quot;Derived ok.\n&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">     ~Derived()&#123;cout &lt;&lt;&quot;Derived out.\n&quot;;&#125;</span><br><span class="line">   protected:</span><br><span class="line">     OBJ1 obj1;//声明顺序</span><br><span class="line">     OBJ2 obj2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Derived aa;//初始化</span><br><span class="line">    cout &lt;&lt;&quot;This is ok.\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Base2 //虚拟基类按照被继承顺序初始化</span><br><span class="line">Base4 //虚拟基类按照被继承的顺序 </span><br><span class="line">Base1 //非虚拟基类按照被继承的顺序初始化</span><br><span class="line">Base3 //非虚拟基类按照被继承的顺序 </span><br><span class="line">OBJ1  //成员函数按照声明的顺序初始化</span><br><span class="line">OBJ2  //成员函数按照声明的顺序 </span><br><span class="line">Derived ok.</span><br><span class="line">This is ok.</span><br><span class="line">Derived out.   //析构函数和构造函数完全相反</span><br><span class="line">~OBJ2</span><br><span class="line">~OBJ1</span><br><span class="line">~Base3</span><br><span class="line">~Base1</span><br><span class="line">~Base4</span><br><span class="line">~Base2</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> c++提高 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[strcpy的实现]]></title>
      <url>/2017/09/24/strcpy%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="实现函数"><a href="#实现函数" class="headerlink" title="实现函数"></a>实现函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char * strcpy(char *  des,const char * src)</span><br><span class="line">&#123;</span><br><span class="line">    if(!src &amp;&amp; !des)</span><br><span class="line">        return NULL;</span><br><span class="line">    int len = strlen(src);</span><br><span class="line">	char * ret = des;</span><br><span class="line">    for(int i = 0;i &lt; len; i++)</span><br><span class="line">        *(des + i)= *(src + i);</span><br><span class="line">    des[len] = &apos;\0&apos;;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解释为什么要返回char"><a href="#解释为什么要返回char" class="headerlink" title="解释为什么要返回char *"></a>解释为什么要返回char *</h1><p>返回des的原始值使函数能够支持链式表达式。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int l=strlen(strcpy(strA,strB));</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> c++提高 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[9月24日笔试总结]]></title>
      <url>/2017/09/24/9%E6%9C%8824%E6%97%A5%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="c-构造函数有哪几种"><a href="#c-构造函数有哪几种" class="headerlink" title="c++构造函数有哪几种"></a>c++构造函数有哪几种</h1><ul>
<li>默认构造函数</li>
<li>初始化构造函数</li>
<li>拷贝构造函数</li>
<li>转换构造函数</li>
</ul>
<p>这里重点介绍转换构造函数：</p>
<h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>当一个构造函数只有一个参数，而且该参数又不是本类的const引用时，这种构造函数称为转换构造函数。不仅可以将一个标准类型数据转换成类对象,也可以将另一个类的对象转换成转换构造函数所在的类对象｡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int age;</span><br><span class="line">    int b;</span><br><span class="line">public:</span><br><span class="line">    A():age(0),b(0) &#123;&#125;;</span><br><span class="line">    A(int a,int b):age(a),b(b)&#123;&#125;</span><br><span class="line">    A(int a):age(a),b(0)&#123;&#125;</span><br><span class="line">    A &amp; operator +(const A &amp; c)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;age  += c.age;</span><br><span class="line">        this-&gt;b    += c.b;</span><br><span class="line">        return * this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A s(10,2);</span><br><span class="line">s + 9;///执行过程</span><br><span class="line"></span><br><span class="line">- 首选调用+号运算符，发现9不是A类的对象，而是int类型</span><br><span class="line">- 然后调用转换构造函数，将9变为A（9）</span><br><span class="line">- 现在便可以进行加法运算</span><br></pre></td></tr></table></figure>
<h1 id="c语言函数值类型缺省定义时，默认是int型"><a href="#c语言函数值类型缺省定义时，默认是int型" class="headerlink" title="c语言函数值类型缺省定义时，默认是int型"></a>c语言函数值类型缺省定义时，默认是int型</h1><h1 id="x-和-x的坑"><a href="#x-和-x的坑" class="headerlink" title="x++和++x的坑"></a>x++和++x的坑</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x++ 只能作为右值，而 （++x） 既可作为左值又可作为右值。（意思就是 x++ 只能放在赋值号右面。）</span><br><span class="line">因为x++是把x的值增一，并返回x原来的值，这个值并不储存在变量x的内存地址中，是计算时的一个临时值，</span><br><span class="line">因此不能向它赋值。而++x是将x的值增一，并返回x的值，因此可以向这个变量赋值。</span><br></pre></td></tr></table></figure>
<p># </p>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[9月23日笔试总结]]></title>
      <url>/2017/09/23/9%E6%9C%8823%E6%97%A5%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="特殊的转义字符"><a href="#特殊的转义字符" class="headerlink" title="特殊的转义字符"></a>特殊的转义字符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;\101&apos;   //表示：‘A’</span><br><span class="line">&apos;\x0A&apos;   //表示换行符</span><br></pre></td></tr></table></figure>
<p>在c/c++程序中使用转义字符\ddd 或者\xhh可以灵活的表示任意字符，\ddd为斜杠后跟三位八进制数，该三位八进制数的值即为对应的八进制ASCII码值。\x后面跟两位十六进制数，该两位十六进制数为对应字符的十六进制ASCII值。</p>
<h1 id="delete和delete-的区别"><a href="#delete和delete-的区别" class="headerlink" title="delete和delete[]的区别"></a>delete和delete[]的区别</h1><p>利用new分配单个对象的内存空间时，使用delete回收。利用new[]分配对象数组时，需要使用delete[]回收。</p>
<p>基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的；但是对于类对象数组，只能用 delete[]，这样程序才会调用每个对象的析构函数。对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间。</p>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[9月22日笔试总结]]></title>
      <url>/2017/09/22/9%E6%9C%8822%E6%97%A5%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="float-类型与“0值”比较"><a href="#float-类型与“0值”比较" class="headerlink" title="float 类型与“0值”比较"></a>float 类型与“0值”比较</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const float EP = 0.000001;</span><br><span class="line">if((x &gt;= -EP) &amp;&amp; (x &lt;= EP))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="声明枚举变量三种方法"><a href="#声明枚举变量三种方法" class="headerlink" title="声明枚举变量三种方法"></a>声明枚举变量三种方法</h1><h2 id="先声明枚举类型后定义枚举类型变量"><a href="#先声明枚举类型后定义枚举类型变量" class="headerlink" title="先声明枚举类型后定义枚举类型变量"></a>先声明枚举类型后定义枚举类型变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum WeekdayType  </span><br><span class="line">&#123;  </span><br><span class="line">    sun,mou,tue,wed,thu,fri,sat  </span><br><span class="line">&#125;;  </span><br><span class="line">enum WeekdayType today,yesterday,tomorrow;</span><br></pre></td></tr></table></figure>
<h2 id="声明枚举类型的同时定义枚举类型变量"><a href="#声明枚举类型的同时定义枚举类型变量" class="headerlink" title="声明枚举类型的同时定义枚举类型变量"></a>声明枚举类型的同时定义枚举类型变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum WeekdayType  </span><br><span class="line">&#123;  </span><br><span class="line">    sun,mou,tue,wed,thu,fri,sat   </span><br><span class="line">&#125;today,yesterday,tomorrow;</span><br></pre></td></tr></table></figure>
<h2 id="直接定义枚举类型变量"><a href="#直接定义枚举类型变量" class="headerlink" title="直接定义枚举类型变量"></a>直接定义枚举类型变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum  </span><br><span class="line">&#123;  </span><br><span class="line">    sun,mou,tue,wed,thu,fri,sat  </span><br><span class="line">&#125;today,yesterday,tomorrow;</span><br></pre></td></tr></table></figure>
<h1 id="不能声明为虚函数"><a href="#不能声明为虚函数" class="headerlink" title="不能声明为虚函数"></a>不能声明为虚函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.普通函数（不能被覆盖） </span><br><span class="line">2.友元函数（C++不支持友元函数继承）</span><br><span class="line">3.内联函数（编译期间展开，虚函数是在运行期间绑定）</span><br><span class="line">4.构造函数（没有对象不能使用构造函数，先有构造函数后有虚函数，虚函数是对对象的动作） </span><br><span class="line">5.静态成员函数（只有一份大家共享）</span><br></pre></td></tr></table></figure>
<p>注意：虚函数是为了解决运行时多态的，所以必须有this指针，因此必须是成员函数</p>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[9月20日笔试总结]]></title>
      <url>/2017/09/20/9%E6%9C%8820%E6%97%A5%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="当型循环"><a href="#当型循环" class="headerlink" title="当型循环"></a>当型循环</h1><p>当型循环结构用在先判断某些条件是否为真，然后重复执行某一段代码的情况下。</p>
<p>补充：直到型循环</p>
<p>直白的说，直到型循环就是先执行循环体，再判断条件是否需要继续往下执行循环体。例如：do….while</p>
<h1 id="常见的转义字符"><a href="#常见的转义字符" class="headerlink" title="常见的转义字符"></a>常见的转义字符</h1><ul>
<li>\a 响铃(BEL) </li>
<li>\b 退格(BS) </li>
<li>\f 换页(FF) </li>
<li>\n 换行(LF)  </li>
<li>\r 回车(CR)  </li>
<li>\t 水平制表(HT) </li>
<li>\v 垂直制表(VT) </li>
<li>\ 反斜杠 </li>
<li>\? 问号字符 </li>
<li>\’ 单引号字符   </li>
<li>\” 双引号字符    </li>
<li>\0 空字符(NULL)  </li>
</ul>
<h1 id="计算一个数中1的个数："><a href="#计算一个数中1的个数：" class="headerlink" title="计算一个数中1的个数："></a>计算一个数中1的个数：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int fun(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(x)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        x = x &amp; (x - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：计算一个数中0的个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int fun(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(x + 1)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        x = x | (x + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小端法的问题"><a href="#小端法的问题" class="headerlink" title="小端法的问题"></a>小端法的问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设在一个 32 位 little endian 的机器上运行下面的程序，结果是多少？</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">  long long a = 1, b = 2, c = 3; </span><br><span class="line">  printf(&quot;%d %d %d\n&quot;, a, b, c);  </span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析：</p>
<ul>
<li>printf是一个库函数，c/c++中的函数参数从右向左入栈</li>
<li>栈的生长方向为：高地址—&gt;底地址</li>
<li>小端模式是底地址存放底位数值</li>
<li>%d格式输出的是4字节的大小，而long long是8字节</li>
</ul>
<p>由上述的四点，我们可以画出如下参数入栈的图：</p>
<p><img src="http://uploadfiles.nowcoder.com/images/20151008/423501_1444290678513_ACED241801E307EE7A39612F85A94EBF" alt="image"></p>
<p>由图可知，最后输出的结果为：</p>
<p>1 0 2</p>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[9月19日笔试总结]]></title>
      <url>/2017/09/19/9%E6%9C%8819%E6%97%A5%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="预定义操作算子"><a href="#预定义操作算子" class="headerlink" title="预定义操作算子"></a>预定义操作算子</h1><p>C++ 提供了大量的用于执行格式化输入 / 输出的流操纵算子。流操纵算子提供了许多功能，如设置域宽、设置精度、设置和清除格式化标志、设置域填充字符、刷新流、在输出流中插入换行符并刷新该流、在输出流中插入空字符、跳过输入流中的空白字符等等。在程序中使用操纵算字必须嵌入头文件 iomanip.h</p>
<h1 id="虚函数的动态绑定"><a href="#虚函数的动态绑定" class="headerlink" title="虚函数的动态绑定"></a>虚函数的动态绑定</h1><p>虚函数会具有动态绑定功能，会按照实际类型调用相关的函数。动态绑定（多态）只有在使用指针和引用时才有效，其他情况下无效。</p>
<h1 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h1><p>指针函数是返回类型是某一类型的指针。比如:  int * foo(int,int);</p>
<h2 id="补充：函数指针"><a href="#补充：函数指针" class="headerlink" title="补充：函数指针"></a>补充：函数指针</h2><p>指向函数的指针包含了函数的地址，可以通过它来调用函数。 声明格式:类型说明符 (<em>函数名)(参数)。比如:void (</em>fptr)(); 函数指针声明的是一个变量。</p>
<h1 id="赋值语句的返回值"><a href="#赋值语句的返回值" class="headerlink" title="赋值语句的返回值"></a>赋值语句的返回值</h1><p>赋值语句的返回值是所赋的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//实验程序</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    cout &lt;&lt; (a = 3) &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指针偏移量的计算"><a href="#指针偏移量的计算" class="headerlink" title="指针偏移量的计算"></a>指针偏移量的计算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned char *p1;</span><br><span class="line">unsigned long *p2;</span><br><span class="line">p1=(unsigned char *)0x801000;</span><br><span class="line">p2=(unsigned long *)0x810000;</span><br><span class="line"></span><br><span class="line">求：</span><br><span class="line">p1+5</span><br><span class="line">p2+5</span><br></pre></td></tr></table></figure>
<p>解析：<br>p1指向unsigned char,所以p1 + 5 = p1 + sizeof(unsigned char) <em> 5<br>p2指向unsigned long,所以p2 + 5 = p1 + sizeof(unsigned long) </em> 5</p>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[程序在内存中的布局]]></title>
      <url>/2017/09/19/%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h1 id="内存布局图"><a href="#内存布局图" class="headerlink" title="内存布局图"></a>内存布局图</h1><p><img src="http://images2015.cnblogs.com/blog/932784/201604/932784-20160430194004941-1042441876.png" alt="image"></p>
<h1 id="各个字段的介绍"><a href="#各个字段的介绍" class="headerlink" title="各个字段的介绍"></a>各个字段的介绍</h1><h2 id="代码段-text"><a href="#代码段-text" class="headerlink" title="代码段(.text)"></a>代码段(.text)</h2><p>存放着机器码和只读数据，程序执行的指令都是从这里获取。这个段的内存一般被标记为只读，任何对该区域的写操作，都会导致段错误。</p>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><h3 id="data"><a href="#data" class="headerlink" title=".data"></a>.data</h3><p>存放着已经初始化的静态变量或全局变量。</p>
<h3 id="bss"><a href="#bss" class="headerlink" title=".bss"></a>.bss</h3><p>存放着未初始化的静态变量或全局变量。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆用来存储运行时分配的变量。堆的大小不固定，其分配由new、malloc等实时内存分配函数实现。当进程调用malloc等函数时，新分配的内存被动态添加到堆上，当使用free等函数释放内存时，被释放的内存从堆中剔除。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是用来存储函数调用时的临时信息的结构，如函数返回地址、函数参数、函数局部变量等。在程序运行时，由编译器在需要时分配，在不需要时自动清除。</p>
<h1 id="堆栈区别"><a href="#堆栈区别" class="headerlink" title="堆栈区别"></a>堆栈区别</h1><h2 id="分配和管理方式不同"><a href="#分配和管理方式不同" class="headerlink" title="分配和管理方式不同"></a>分配和管理方式不同</h2><ul>
<li>堆是动态分配的，其空间的分配和释放都由程序员控制。</li>
<li>栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。</li>
</ul>
<h2 id="产生碎片不同"><a href="#产生碎片不同" class="headerlink" title="产生碎片不同"></a>产生碎片不同</h2><ul>
<li>对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。</li>
<li>对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。</li>
</ul>
<h2 id="生长方向不同"><a href="#生长方向不同" class="headerlink" title="生长方向不同"></a>生长方向不同</h2><ul>
<li>堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长。</li>
<li>栈的生长方向与之相反，是向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。</li>
</ul>
<p>注意：由于栈的大小一般是可以确定的，所以栈可以从高地址向低地址增长。</p>
]]></content>
      
        
        <tags>
            
            <tag> c++提高 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[9月17日笔试总结]]></title>
      <url>/2017/09/17/9%E6%9C%8817%E6%97%A5%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="常见数据类型的值的范围"><a href="#常见数据类型的值的范围" class="headerlink" title="常见数据类型的值的范围"></a>常见数据类型的值的范围</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned   int    0 ~ 4294967295              (0 ~ 2^32 - 1)</span><br><span class="line">int              -2147483648 ～ 2147483647    (-2^31 ~ 2^31 -1)</span><br><span class="line">unsigned   long  0 ~ 4294967295               (0 ~ 2^32 - 1)</span><br><span class="line">long             -2147483648～2147483647      (-2^31 ~ 2^31 -1)</span><br><span class="line">unsigned short   0 ~ 655375                   (0 ~ 2^16 - 1)</span><br><span class="line">short           -32768~32767                  (-2^15 ~ 2^15 - 1)</span><br></pre></td></tr></table></figure>
<h1 id="用户态切换到内核态3种方式"><a href="#用户态切换到内核态3种方式" class="headerlink" title="用户态切换到内核态3种方式"></a>用户态切换到内核态3种方式</h1><ul>
<li>系统调用</li>
<li>异常</li>
<li>外围设备中断</li>
</ul>
<h1 id="单精度和双精度问题"><a href="#单精度和双精度问题" class="headerlink" title="单精度和双精度问题"></a>单精度和双精度问题</h1><ol>
<li>一个浮点数由三个部分组成：符号位S、指数部分（E）以及尾数部分M</li>
<li>单精度浮点数（float）总共由32位表示，其中尾数用23存储，加上小数点前有一位隐藏的1。所以尾数最大值为：2^(23+1) = 16777216,因为10^7 &lt; 16777216 &lt; 10^8，所以说单精度的有效位数位7位。</li>
<li>双精度浮点数(double)总共用64位来表示浮点数，其中尾数用52位存储，2^(52+1) = 9007199254740992，10^16 &lt; 9007199254740992 &lt; 10^17，所以双精度的有效位数是16位。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++ 11 lambda表达式解析]]></title>
      <url>/2017/09/15/c++11-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>今天在复习秋招的时候，刚好碰到了一道lambda表达式的题目，所以在此学习了一下这方面的知识，参考博客：</p>
<ul>
<li><a href="http://www.cnblogs.com/haippy/archive/2013/05/31/3111560.html" target="_blank" rel="noopener">C++11 lambda 表达式解析</a>    </li>
<li><a href="http://blog.csdn.net/fjzpdkf/article/details/50249287" target="_blank" rel="noopener">C++11 学习笔记 lambda表达式</a></li>
</ul>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><p>lambda表达式是c++ 11新增的一个特性。它可以方便的构造匿名函数。如果你的代码中需要大量的小函数，而且这些函数只需要调用一次，那么不妨把它们重构为lambda表达式。</p>
<h1 id="lambda表达式声明方式如下："><a href="#lambda表达式声明方式如下：" class="headerlink" title="lambda表达式声明方式如下："></a>lambda表达式声明方式如下：</h1><p>（1）[ capture ] ( params ) opt  -&gt; ret { body }<br>（2）[ capture ] ( params ) -&gt; ret { body }<br>（3）[ capture ] ( params ) { body }<br>（4）[ capture ] { body }    </p>
<p>其中：</p>
<ul>
<li>（1）是完整的lambda表示式形式。</li>
<li>（2）const类型的lambda表达式，该类型的表达式不能改捕获(“capture”)列表中的值。</li>
<li><p>（3）省略了返回值类型的 lambda 表达式，但是该 lambda 表达式的返回类型可以按照下列规则推演出来：</p>
<p>1、如果 lambda 代码块中包含了 return 语句，则该 lambda 表达式的返回类型由    return 语句的返回类型确定。</p>
<p>2、如果没有 return 语句，则类似 void f(…) 函数</p>
</li>
<li><p>（4）省略了参数列表，类似于无参函数 f()。</p>
</li>
</ul>
<h1 id="capture介绍"><a href="#capture介绍" class="headerlink" title="capture介绍"></a>capture介绍</h1><p>capture是捕获列表；其具体解释如下：</p>
<ul>
<li>[a,&amp;b] a变量以值的方式呗捕获，b以引用的方式被捕获。</li>
<li>[this] 以值的方式捕获 this 指针。</li>
<li>[&amp;] 以引用的方式捕获所有的外部自动变量。</li>
<li>[=] 以值的方式捕获所有的外部自动变量。</li>
<li>[] 不捕获外部的任何变量。</li>
</ul>
<h1 id="opt介绍"><a href="#opt介绍" class="headerlink" title="opt介绍"></a>opt介绍</h1><p>opt是函数选项；可以填mutable,exception,attribute（选填）</p>
<p>mutable 修饰符说明 lambda 表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获对象的 non-const 方法。</p>
<p>exception 说明 lambda 表达式是否抛出异常(noexcept)，以及抛出何种异常，类似于void f() throw(X, Y)。</p>
<p>attribute 用来声明属性。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto fun = [] (unsigned char a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; std::hex &lt;&lt; (int)a &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fun(-1);</span><br></pre></td></tr></table></figure>
<p>如上代码所示，我们声明了一个匿名的函数，并且赋值给了fun，所以程序最终输出：ff。</p>
]]></content>
      
        
        <tags>
            
            <tag> c++提高 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++运算符优先级问题]]></title>
      <url>/2017/09/15/c++%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="运算符优先级列表"><a href="#运算符优先级列表" class="headerlink" title="运算符优先级列表"></a>运算符优先级列表</h1><p><img src="http://img2.ph.126.net/8EYzAxxQv63-W1yBgAcXtw==/2590977160640107298.jpg" alt="image"></p>
<h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 2;</span><br><span class="line">int b = 3;</span><br><span class="line">int c = a++,b++;</span><br></pre></td></tr></table></figure>
<p>由于逗号的优先级最低，所以会先执行赋值运算符先，因此c的值等于a的值。如果将上述的代码修改为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 2;</span><br><span class="line">int b = 3;</span><br><span class="line">int c = (a++,b++);</span><br></pre></td></tr></table></figure>
<p>由于加了括号，所以先执行了逗号运算符，最后执行赋值运算符，因此c的值等于b的值</p>
]]></content>
      
        
        <tags>
            
            <tag> c++提高 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++字节对齐问题]]></title>
      <url>/2017/09/14/c++%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="为什么需要字节对齐"><a href="#为什么需要字节对齐" class="headerlink" title="为什么需要字节对齐"></a>为什么需要字节对齐</h1><ul>
<li>某些平台只能在特定的地址处访问特定的类型的数据。</li>
<li>提高存取数据的速度</li>
</ul>
<h1 id="对齐的准则"><a href="#对齐的准则" class="headerlink" title="对齐的准则"></a>对齐的准则</h1><ul>
<li>数据类型自身对齐值： char为1字节，short为2字节，long/int/float为4字节，double/long long为8字节。</li>
<li>结构体或类自身对齐值：它最后的对齐值为其成员变量中自身对齐值中最大的那个值的整数倍。</li>
<li>指定对齐值：#pragma pack (value)时的指定对齐值value</li>
<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}</li>
</ul>
<h1 id="位域对齐方式"><a href="#位域对齐方式" class="headerlink" title="位域对齐方式"></a>位域对齐方式</h1><ul>
<li>如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；</li>
<li>如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；</li>
<li>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++和GCC采取压缩方式；</li>
<li>如果位域字段之间穿插着非位域字段，则不进行压缩</li>
<li>整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct StructBitField&#123;</span><br><span class="line">    int element1   : 1;</span><br><span class="line">    int element2   : 5;</span><br><span class="line">    int element3   : 29;</span><br><span class="line">    int element4   : 6;</span><br><span class="line">    char element5  :2;</span><br><span class="line">    char stelement;  //在含位域的结构或联合中也可同时说明普通成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体中最宽类型int为4字节，因此结构体按照4字节对齐。所以在vc6中，其sizeof为16.</p>
<h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct s</span><br><span class="line">&#123;</span><br><span class="line">    int x: 3;</span><br><span class="line">    int y: 4;</span><br><span class="line">    int z: 5;</span><br><span class="line">    double a;</span><br><span class="line">&#125;;</span><br><span class="line">求sizeof(s)</span><br></pre></td></tr></table></figure>
<p>分析：<br>首先结构体中最宽的是8字节的double，所以结构体按照8字节对齐。而我们发现x，y，z属于int型的位域，而且三个位域所占的位数为12位，未超过一个int型所占的32位，因此只需要4个字节就可以表示xyz。另外，由于double自身的对齐方式为：8字节，所以最终sizeof(s) = 16.</p>
]]></content>
      
        
        <tags>
            
            <tag> c++提高 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++内联函数]]></title>
      <url>/2017/09/13/c++%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="什么是内联函数"><a href="#什么是内联函数" class="headerlink" title="什么是内联函数"></a>什么是内联函数</h1><p>内联函数是c++的一个增强的特性，用来降低程序运行时间。所谓的内联就是：编译器将使用函数定义体代替函数调用语句，需要注意的是这种代替发生在编译阶段而非程序运行阶段。</p>
<p>注意：内联函数只是给编译器一个内联的建议，编译器需要根据实际的函数是否符合内联的有利条件来决定是否采用内联建议。如果函数体过大，则编译器将忽略函数的内联声明</p>
<h1 id="内联函数的使用"><a href="#内联函数的使用" class="headerlink" title="内联函数的使用"></a>内联函数的使用</h1><p>需要使用内联函数的时候，只需要在函数定义的前面加上“inline”关键字。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//普通函数声明</span><br><span class="line">inline int add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//类函数中的使用</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int add(int a, int b);</span><br><span class="line">&#125;</span><br><span class="line">inline int Test::add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="为什么要使用内联函数"><a href="#为什么要使用内联函数" class="headerlink" title="为什么要使用内联函数"></a>为什么要使用内联函数</h1><p>我们知道调用一个函数需要做事情包括：保存当前函数执行的现场，将函数局部变量以及函数的返回地址压入堆栈中，然后再将即将调用的新函数加载到内存中，这要经历复制参数值、跳转到所调用函数的内存位置、执行函数代码、存储函数返回值等过程，当函数执行完后，再获取之前正在调用的函数的地址，回去继续执行那个函数，运行时间开销简直太多了。</p>
<p>所以有时候我们会写一些功能专一的函数，这些函数的函数体不大，包含了很少的执行语句，这个时候就可以使用内联函数。</p>
<h1 id="使用内联函数需要注意的问题"><a href="#使用内联函数需要注意的问题" class="headerlink" title="使用内联函数需要注意的问题"></a>使用内联函数需要注意的问题</h1><ol>
<li>所有类中定义的函数都默认声明为inline函数，所有我们不用显示地去声明inline。</li>
<li>虚函数不允许内联</li>
<li>在内联函数中，不允许使用循环语句和switch语句。</li>
<li>带有异常接口的函数不能声明为内联函数</li>
<li>递归函数不能声明为内联函数</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> c++提高 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fcntl函数]]></title>
      <url>/2017/09/02/fcntl%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h1><p>fcntl函数提供了对文件描述符的各种控制操作。fcntl函数是由POSIX规范指定的首先方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int fcntl(int fd, int cmd,...);</span><br></pre></td></tr></table></figure>
<h1 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h1><p>fd参数是被操作的文件描述符，cmd参数指定指向何种类型的操作。根据操作类型的不同，该函数可能还需要第三个可选参数arg。fcntl函数支持的常用操作和参数如下表：<br><img src="http://img1.ph.126.net/YSTxzXfalbOhku_h6DWf7w==/2605613859428883346.jpg" alt="image"></p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>成功时的返回值，见上表。失败时，则返回-1并设置errno。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[sendfile函数]]></title>
      <url>/2017/09/02/sendfile%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h1><p>sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/sendfile.h&gt;</span><br><span class="line">ssize_t sendfile(int out_fd,int in_fd, off_t * offset,size_t count);</span><br></pre></td></tr></table></figure>
<h1 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h1><p>in_fd参数是待读出内容的文件描述符，out_fd参数是待写入内容的文件描述符。offset参数指定从读入文件流哪个位置开始读，如果是空，则使用读入文件流默认的起始位置。count参数指定在文件描述符in_fd和out_fd之间传输的字节数。</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>成功，则返回传输的字节数，失败，则返回-1，并设置errno。</p>
<p>注意：in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道。而out_fd必须是一个socket。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[readv函数和writev函数]]></title>
      <url>/2017/09/02/readv%E5%87%BD%E6%95%B0%E5%92%8Cwritev%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="readv函数和writev函数"><a href="#readv函数和writev函数" class="headerlink" title="readv函数和writev函数"></a>readv函数和writev函数</h1><p>readv函数将数据从文件描述符中读到分散的内存块中，即分散读；writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line">ssize_t readv(int fd,const struct iovec * vector,int count);</span><br><span class="line">ssize_t writev(int fd,const struct iovec * vector,int count);</span><br></pre></td></tr></table></figure>
<h1 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h1><p>fd参数是被操作的目标文件描述符。vector参数的类型是iovec结构数组（参考：<a href="https://ouyanglianjun.github.io/2017/08/28/%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/" target="_blank" rel="noopener">通用数据读写</a>）。count参数是vector数组的长度，即有多少块内存块需要从fd读出或者写入到fd中。</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>成功返回读出或写入的字节数。失败，则返回-1，并且设置errno。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dup函数和dup2函数]]></title>
      <url>/2017/09/02/dup%E5%87%BD%E6%95%B0%E5%92%8Cdup2%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="dup函数和dup2函数"><a href="#dup函数和dup2函数" class="headerlink" title="dup函数和dup2函数"></a>dup函数和dup2函数</h1><p>有时候，我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接中（如CGI编程）。这个时候可以通过下面用于复制文件描述符的dup或dup2函数实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int file_description);</span><br><span class="line">int dup2(int file_description_one, int file_description_two);</span><br></pre></td></tr></table></figure>
<h1 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h1><h2 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h2><p>dup函数创建一个新的文件描述符，该新的文件描述符和原有文件描述符file_description指向相同的文件、管道或者网络连接。并且dup返回系统最小可用的文件描述符。</p>
<h2 id="dup2函数"><a href="#dup2函数" class="headerlink" title="dup2函数"></a>dup2函数</h2><p>dup2和dup作用是一样的，不过它将返回第一个不小于file_description_two的文件描述符。</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>成功，则返回新的的文件描述符。失败，则返回-1，并且设置errno。</p>
<p>注意：通过dup和dup2创建的文件描述符并不继承原文件描述符的属性，比如：close-on-exec和non-blocking等，这个时候需要使用fcntl来设置。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络信息API]]></title>
      <url>/2017/08/29/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AFAPI/</url>
      <content type="html"><![CDATA[<h1 id="获取主机信息的函数"><a href="#获取主机信息的函数" class="headerlink" title="获取主机信息的函数"></a>获取主机信息的函数</h1><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p>gethostbyname函数根据主机名获取主机的完整信息。它通常是先在本地的/etc/hosts配置文件中查找主机，没有找到，再去访问DNS服务器。gethostbyaddr函数根据主机地址获取主机的完整信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">struct hostent * gethostbyname(const char * name);</span><br><span class="line">struct hostent * gethostbyaddr(const void * addr, size_t len, int type);</span><br></pre></td></tr></table></figure>
<h2 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h2><p>name参数指定目标主机的主机名。</p>
<p>addr参数指定目标主机的IP地址，len参数与指定addr所指的IP地址长度，type参数指定addr所指IP地址的类型，其合法取值包括：AF_INET和AF_INET6。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>两个函数的返回值都是hostent结构体类型的指针，hostent结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line">sturct hostent</span><br><span class="line">&#123;</span><br><span class="line">    char * h_name;              /*  主机名                              */</span><br><span class="line">    char ** h_aliases;          /*   主机别名列表，                     */</span><br><span class="line">    int h_addrtype;             /*   地址类型                           */</span><br><span class="line">    int h_length;               /*    地址长度                          */</span><br><span class="line">    char ** h_addr_list;        /*    按网络字节序列出的主机IP地址列表  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="获取某个服务的信息"><a href="#获取某个服务的信息" class="headerlink" title="获取某个服务的信息"></a>获取某个服务的信息</h1><h2 id="函数介绍-1"><a href="#函数介绍-1" class="headerlink" title="函数介绍"></a>函数介绍</h2><p>getservbyname函数根据名称来获取某个服务的完整信息，getservbyport函数根据端口号获取某个服务的完整信息。它们实际上都是通过读取/etc/services文件来获取服务的信息的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netdb.h&gt;</span><br><span class="line"></span><br><span class="line">struct servent * getservbyname(const char *name,const char * proto);</span><br><span class="line">struct servent * getservbyport(int port, const char * proto);</span><br></pre></td></tr></table></figure>
<h2 id="参数介绍-1"><a href="#参数介绍-1" class="headerlink" title="参数介绍"></a>参数介绍</h2><p>name参数指定目标服务的名字。</p>
<p>port参数指定目标服务对应的端口号。proto参数指定服务类型，给它传递“tcp”表示获取流服务，给它传递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的服务。</p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>这两个函数都是返回servent结构体类型指针，servent结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct servent</span><br><span class="line">&#123;</span><br><span class="line">    char * s_name;                      /*  服务名称                   */</span><br><span class="line">    char ** s_aliases;                  /*   服务别名                  */</span><br><span class="line">    int s_port;                         /*    端口号                   */</span><br><span class="line">    char * s_proto;                     /*    服务类型，通常是tcp或udp */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面的这个四个函数都是不可重入的，也就是非线程安全的。不过netdb.h头文件给出它们的可重入版本。只需要在这些函数的原函数名尾部加上_r。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gethostbyname_r</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用的套接字选项介绍]]></title>
      <url>/2017/08/29/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a>SO_REUSEADDR选项</h1><p>经过setsockopt设置了SO_REUSEADDR选项后，即使当前套接字处于TIME_WAIT状态，与之绑定的socket地址也可以被立即重用。此外，我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本不进入TIME_WAIT状态，进而允许应用程序立即重用本地的socket地址。</p>
<h1 id="SO-RECVBUF和SO-SNDBUF选项"><a href="#SO-RECVBUF和SO-SNDBUF选项" class="headerlink" title="SO_RECVBUF和SO_SNDBUF选项"></a>SO_RECVBUF和SO_SNDBUF选项</h1><p>SO_RECVBUF和SO_SNDBUF选项分别表示TCP接收缓冲区和发送缓冲区的大小。只是，但我们使用setsockopt来设置TCP的接收缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且TCP的发送缓冲区的最小值是256字节，而发送缓冲区的最小值是2048字节。</p>
<p>注意：<br>可以通过强制修改内核参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/proc/sys/net/ipv4/tcp_rmem</span><br><span class="line"></span><br><span class="line">/proc/sys/net/ipv4/tcp_wmem</span><br></pre></td></tr></table></figure>
<p>来修改TCP的接收和发送缓冲区。</p>
<h1 id="SO-RCVLOWAT和SO-SNDLOWAT选项"><a href="#SO-RCVLOWAT和SO-SNDLOWAT选项" class="headerlink" title="SO_RCVLOWAT和SO_SNDLOWAT选项"></a>SO_RCVLOWAT和SO_SNDLOWAT选项</h1><p>SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的底水位标记。它们一般被I/O复用系统调用来判断socket是否可读或可写。</p>
<ul>
<li>当TCP接收缓冲区中可读数据总数大于其低水位的标记时，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据了。</li>
<li>当TCP发送缓冲区空闲的空间大于其低水位标记时，，I/O复用系统调用将通知应用程序可以往对应的socket上写数据了</li>
</ul>
<p>默认情况下，TCP缓冲区的低水位标记和TCP发送缓冲区的底水位标记均为1字节。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[套接字选项的介绍]]></title>
      <url>/2017/08/29/%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="套接字选项设置和获取函数"><a href="#套接字选项设置和获取函数" class="headerlink" title="套接字选项设置和获取函数"></a>套接字选项设置和获取函数</h1><p>在进行网络编程的时候，我们需要经常去查看并且设置套接字的某些特性。例如我们想去设置地址复用，设置读写数据的超时时间，想对读写缓冲区的大小进行调整，其中获得套接字的选项就是getsckopt()函数，那么对应的设置套接字的选项就是sesockopt()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int getsockopt(int sockfd, int level, int option_name, void * option_value,socklen_t * option_len);</span><br><span class="line"></span><br><span class="line">int setsockopt(int sockfd, int level, int option_name, const void * option_value,socklen_t * option_len);</span><br></pre></td></tr></table></figure>
<h1 id="参数的介绍"><a href="#参数的介绍" class="headerlink" title="参数的介绍"></a>参数的介绍</h1><h2 id="sockfd"><a href="#sockfd" class="headerlink" title="sockfd"></a>sockfd</h2><p>指定被操作的目标socket</p>
<h2 id="level"><a href="#level" class="headerlink" title="level"></a>level</h2><p>指定要操作哪个协议的选项，按照level可以把套接字选项分为如下三种：</p>
<ol>
<li>通用套接选项：level的值为SOL_SOCKET</li>
<li>IP选项：level的值为IPPROTO_IP</li>
<li>TCP选项：level的值为IPPROTO_TCP</li>
</ol>
<h2 id="option-name"><a href="#option-name" class="headerlink" title="option_name"></a>option_name</h2><p>需要访问的选项名。</p>
<h2 id="option-value和option-len"><a href="#option-value和option-len" class="headerlink" title="option_value和option_len"></a>option_value和option_len</h2><p>被操作的选项的值和长度</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>执行成功的时候返回值为0，函数执行失败时返回为-1并设置errno</p>
<h1 id="套接字选项的列表"><a href="#套接字选项的列表" class="headerlink" title="套接字选项的列表"></a>套接字选项的列表</h1><p><img src="http://blog.hotwill.cn/assets/img/socket%E9%80%89%E9%A1%B9.png" alt="image"></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu双系统导致进win7花屏]]></title>
      <url>/2017/08/29/ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%87%B4%E8%BF%9Bwin7%E8%8A%B1%E5%B1%8F/</url>
      <content type="html"><![CDATA[<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ol>
<li>sudo vim /etc/default/grub</li>
<li>修改下面两行的内容</li>
</ol>
<p>修改前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;  </span><br><span class="line"></span><br><span class="line"># Uncomment to disable graphical terminal (grub-pc only)  </span><br><span class="line">#GRUB_TERMINAL=console</span><br></pre></td></tr></table></figure></p>
<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash nomodeset“  </span><br><span class="line"></span><br><span class="line"># Uncomment to disable graphical terminal (grub-pc only)  </span><br><span class="line">GRUB_TERMINAL=console</span><br></pre></td></tr></table></figure>
<p>3.sudo update-grub</p>
]]></content>
      
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[地址信息函数]]></title>
      <url>/2017/08/28/%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h1><p>在某些情况下，我们想知道一个连接socket的本端socket地址，以及远端的socket地址。下面这两个函数正是用于解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int getsockname(int sockfd, struct sockaddr * address, socklen_t * addr_len);</span><br><span class="line">int getpeername(int sockfd, struct sockaddr * address, socklen_t * addr_len);</span><br></pre></td></tr></table></figure>
<h1 id="函数参数介绍"><a href="#函数参数介绍" class="headerlink" title="函数参数介绍"></a>函数参数介绍</h1><p>getsocketname获取sockfd对应的本端socket地址，并将其存储于address参数指定的内存中，该socket地址的长度则存储于addr_len参数指向的变量中。</p>
<p>getpeername获取sockfd对应的远端socket地址，参数的含义和getsocketname的参数一样。</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>getsocketname成功时返回0，失败则返回-1并设置errno。</p>
<p>getpeername成功时返回0，失败时返回-1并设置errno。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通用数据读写]]></title>
      <url>/2017/08/28/%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/</url>
      <content type="html"><![CDATA[<h1 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t recvmsg(int sockfd, struct msghdr * msg, int flags);</span><br><span class="line"></span><br><span class="line">ssize_t sendmsg(int sockfd, struct msghdr * msg, int flags);</span><br></pre></td></tr></table></figure>
<h1 id="函数参数介绍"><a href="#函数参数介绍" class="headerlink" title="函数参数介绍"></a>函数参数介绍</h1><h2 id="sockfd参数"><a href="#sockfd参数" class="headerlink" title="sockfd参数"></a>sockfd参数</h2><p>sockfd参数指定被操作的目标socket。</p>
<h2 id="msg参数"><a href="#msg参数" class="headerlink" title="msg参数"></a>msg参数</h2><p>msg参数是msghdr结构体类型的指针，该结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct msghdr</span><br><span class="line">&#123;</span><br><span class="line">    void * msg_name;                //socket地址</span><br><span class="line">    socklen_t msg_namelen;          //socket地址长度</span><br><span class="line">    struct iovec * msg_iov;         //分散内存块</span><br><span class="line">    int msg_iovlen;                 //分散内存块的长度</span><br><span class="line">    void * msg_control;             //指向辅助数据的起始位置</span><br><span class="line">    socklen_t msg_controllen;       //辅助数据的大小</span><br><span class="line">    int msg_flags;                  //复制函数中的flags参数，并在调用过程中更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于面向连接的TCP协议，该字段无意义，必须设置为NULL。msg_namelen成员指定了msg_name的长度。</p>
<p>msg_iov成员是iovec结构体类型的指针，iovec结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct iovec</span><br><span class="line">&#123;</span><br><span class="line">    void * iov_base;    //内存起始地址</span><br><span class="line">    size_t iov_len;     //这块内存的长度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上结构可知，iovec结构体封装了一块内存的起始位置和长度。msg_iovlen指定这样的iovec结构对象有多少个。对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中；称为分散读。而且对于sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，这被称为集中写。</p>
<p>msg_control和msg_controllen成员用于辅助数据的传送。msg_flags成员无需设定，它会复制recvmsg/sendmsg的flags参数的内容以影响数据读写的过程。</p>
<h2 id="flags参数"><a href="#flags参数" class="headerlink" title="flags参数"></a>flags参数</h2><p>flags参数和recv/send函数的flags参数的相同。具体参考：<a href="https://ouyanglianjun.github.io/2017/08/27/TCP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/" target="_blank" rel="noopener">TCP数据读写</a></p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>成功时候返回读写字节数，出错时候返回-1.</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UDP数据读写]]></title>
      <url>/2017/08/27/UDP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/</url>
      <content type="html"><![CDATA[<h1 id="UDP数据读写函数"><a href="#UDP数据读写函数" class="headerlink" title="UDP数据读写函数"></a>UDP数据读写函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t * addrlen);</span><br><span class="line"></span><br><span class="line">ssize_t sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr * dest_addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<h1 id="recvfrom函数介绍"><a href="#recvfrom函数介绍" class="headerlink" title="recvfrom函数介绍"></a>recvfrom函数介绍</h1><p>recvfrom函数读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。flags参数和recv/send函数的flags参数的相同。具体参考：<a href="https://ouyanglianjun.github.io/2017/08/27/TCP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/" target="_blank" rel="noopener">TCP数据读写</a></p>
<h1 id="sendto函数的介绍"><a href="#sendto函数的介绍" class="headerlink" title="sendto函数的介绍"></a>sendto函数的介绍</h1><p>sendto函数往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接收端的socket的地址，addrlen参数则指定该地址的长度。flags参数和recv/send函数的flags参数的相同。具体参考：<a href="https://ouyanglianjun.github.io/2017/08/27/TCP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/" target="_blank" rel="noopener">TCP数据读写</a></p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>成功时候返回读写字节数，出错时候返回-1.</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP数据读写]]></title>
      <url>/2017/08/27/TCP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/</url>
      <content type="html"><![CDATA[<h1 id="TCP数据读写函数"><a href="#TCP数据读写函数" class="headerlink" title="TCP数据读写函数"></a>TCP数据读写函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t recv(int sockfd, void * buf, size_t len, int flags);</span><br><span class="line">ssize_t send(int sockfd, void * buf, size_t len, int flags);</span><br></pre></td></tr></table></figure>
<h1 id="recv函数介绍"><a href="#recv函数介绍" class="headerlink" title="recv函数介绍"></a>recv函数介绍</h1><h2 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h2><p>recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数通常设置为0.</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>recv函数成功时，返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此需要多次调用recv，才能读取到完整的数据。recv可能返回0，这意味着通信对方已经断开了连接。recv出错时，返回-1并设置errno。</p>
<h1 id="send函数介绍"><a href="#send函数介绍" class="headerlink" title="send函数介绍"></a>send函数介绍</h1><h2 id="参数介绍-1"><a href="#参数介绍-1" class="headerlink" title="参数介绍"></a>参数介绍</h2><p>send函数往sockfd上发送数据，buf和len分别指定发送缓冲区的位置和大小,flags参数一般设置为0。</p>
<h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>send成功时，返回实际写入到sockfd的数据长度。失败时，返回-1并设置errno。</p>
<h1 id="flags参数总结"><a href="#flags参数总结" class="headerlink" title="flags参数总结"></a>flags参数总结</h1><p>flags参数为数据收发提供了额外的控制。具体可以见下表，在使用的时候可以选择选项中的一个或多个的逻辑或。</p>
<p><img src="http://i2.bvimg.com/593129/30cd844236e3f4f1.png" alt="image"></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[折半查找]]></title>
      <url>/2017/08/15/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在有序队列中，将查找的关键字和查找范围内的中间元素进行比较，会出现如下三种情况：</p>
<ol>
<li>关键字和该中间元素相等，则查找成功。</li>
<li>如果关键字比该中间元素大，则将整个查找范围的后半部分作为新的查找范围，重新进行折半查找算法。</li>
<li>如果关键字比该中间元素小，则将整个查找范围的前半部分作为新的查找范围，重新进行折半查找算法。</li>
<li>中间元素不等于关键字且查找范围小于等于1，则说明查找失败。</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int binary_search(int * data, int len,int key)</span><br><span class="line">&#123;</span><br><span class="line">	int low = 0;</span><br><span class="line">	int high = len - 1;</span><br><span class="line">	int mid = 0;</span><br><span class="line">	/* 判断查找范围是否大于等于0  */</span><br><span class="line">	while (low &lt;= high)    </span><br><span class="line">	&#123;</span><br><span class="line">	    /* 首先取中间值 */</span><br><span class="line">		mid = low + (high - low) / 2;</span><br><span class="line">		/* 相等，则直接返回 */</span><br><span class="line">		if (data[mid] == key)</span><br><span class="line">		&#123;</span><br><span class="line">			return mid + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		/* 小于则，取前半部分 */</span><br><span class="line">		else if (data[mid] &gt; key)</span><br><span class="line">		&#123;</span><br><span class="line">			high = mid - 1;</span><br><span class="line">		&#125;</span><br><span class="line">		/* 大于则，取后半部分 */</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			low = mid + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int data[5] = &#123; 10, 2, 20, 15, 16 &#125;;</span><br><span class="line">	int len = 5;</span><br><span class="line">	printf(&quot;%d\n&quot;, binary_search(data, len, 20));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="折半查找性能分析"><a href="#折半查找性能分析" class="headerlink" title="折半查找性能分析"></a>折半查找性能分析</h1><p>查找算法性能的指标就两个：</p>
<ul>
<li>查找成功时，平均的查找长度，折半查找平均查找长度为：((n+1)/n)*(log(n+1)-1)</li>
<li>查找失败时，需要比较的次数, 折半查找最多比较次数为：log(n)+1</li>
</ul>
<p><strong>注意：折半查找为有序表查找算法，它不适用于无序的顺序表和链表中。</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> 查找算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关闭连接]]></title>
      <url>/2017/08/13/%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>
<h1 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h1><p>fd参数是待关闭的socket。不过，close系统调用并非总是立即关闭一个连接而是先将fd的引用计数减一。只有当fd的引用数为0时，才真正关闭。多进程程序中，一次fork的系统调用默认将使父进程中打开的socket的引用计数加1.所以我们必须在父进程和子进程中都对该socket执行close。</p>
<h1 id="其他关闭函数"><a href="#其他关闭函数" class="headerlink" title="其他关闭函数"></a>其他关闭函数</h1><p>由于close系统调用并不是马上就关闭连接而是减少其引用次数。如果想马上关闭连接，可以使用shutdown系统调用。</p>
<h2 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int shutdown(int sockfd, int howto);</span><br></pre></td></tr></table></figure>
<h2 id="形参-1"><a href="#形参-1" class="headerlink" title="形参"></a>形参</h2><p>sockfd为待关闭的socket。howto参数决定了shutdown的行为，它可取的值如下：<br><img src="http://i4.fuimg.com/593129/973e4d4cbcfe62e1.png" alt="image"></p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>成功返回0，失败则返回-1并设置errno。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[发起连接]]></title>
      <url>/2017/08/13/%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int connect(int sockfd, const struct sockaddr * serv_addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<h1 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h1><p>sockfd参数是<a href="https://ouyanglianjun.github.io/2017/08/13/%E5%88%9B%E5%BB%BAsocket/" target="_blank" rel="noopener">socket系统调用</a>返回的一个文件描述符。serv_addr参数是服务器监听的<a href="https://ouyanglianjun.github.io/2017/08/13/socket%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">socket地址</a>信息，addrlen参数则指定这个地址的长度。</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>connect成功返回0，失败返回-1，并且设置errno的值。常见的errno的值为：</p>
<ul>
<li>ECONNREFUSED：目标端口不存在，连接被拒绝，这个在之前介绍<a href="https://ouyanglianjun.github.io/2017/08/13/%E7%9B%91%E5%90%ACsocket/" target="_blank" rel="noopener">监听socket</a>时，提到了这个错误信息。</li>
<li>ETIMEDOUT：连接超时。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[接收连接]]></title>
      <url>/2017/08/13/%E6%8E%A5%E6%94%B6%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int accept(int sockfd,struct sockaddr * addr,socklen_t * addrlen);</span><br></pre></td></tr></table></figure>
<h1 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h1><p>sockfd参数是执行listen系统调用监听的socket。addr参数用来获取被接受连接的远端socket地址，该socket地址的长度由addrlen参数指出。</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>成功时，返回一个文件描述符，用来标识被接受的这个连接，服务器可通过读写该文件描述符与被连接的对应的客户端通信。如果accept失败，则返回-1，并且设置errno。</p>
<h1 id="accept函数扩展"><a href="#accept函数扩展" class="headerlink" title="accept函数扩展"></a>accept函数扩展</h1><p>accept只是从监听队列中取出连接，而不论连接处于何种状态，更不关心任何网络状况的变化；因此如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现了网络异常，或者提前退出，服务器对这个连接执行的accept函数是可以正常返回的。</p>
<p><strong>注意：检测客户端网络出现异常的情况的通常采用的方式是服务端发送心跳包。</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[监听socket]]></title>
      <url>/2017/08/13/%E7%9B%91%E5%90%ACsocket/</url>
      <content type="html"><![CDATA[<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd,int backlog);</span><br></pre></td></tr></table></figure>
<h1 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h1><p>sockfd参数指定了需要监听的socket，backlog指定了内核监听队列的最大长度。</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>成功时，返回0，失败则返回-1，并设置errno。</p>
<h1 id="有关backlog的知识"><a href="#有关backlog的知识" class="headerlink" title="有关backlog的知识"></a>有关backlog的知识</h1><p>监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。</p>
<p>在内核版本2.2之前的Linux中，backlog参数是指所有处于半连接状态（SYN_RCVD）和完全连接状态（ESTABLISHED）的socket的上限。但是自2.2版本后，它只表示处于完全连接状态的socket的上限。处于半连接状态的socket的上限则由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命名socket]]></title>
      <url>/2017/08/13/%E5%91%BD%E5%90%8Dsocket/</url>
      <content type="html"><![CDATA[<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd,const struct sockaddr * my_addr,socklen_t addrlen);</span><br></pre></td></tr></table></figure>
<h1 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h1><p>bind将my_addr所指的<a href="https://ouyanglianjun.github.io/2017/08/13/socket%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">sockaddr地址</a>分配给未命名的sockfd文件描述符。addrlen参数指出my_addr的长度。</p>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>bind成功返回0，失败则返回-1并设置errno。其中两个常见的errno如下：</p>
<ol>
<li>EACCES:被绑定的地址是受保护的地址。比如普通用户将socket绑定到知名服务端口（0~1023）上。</li>
<li>EADDRINUSE：被绑定的地址正在使用中。比如将socket绑定到一个处于TIME_WAIT状态的socket地址。</li>
</ol>
<h1 id="命名socket的原因"><a href="#命名socket的原因" class="headerlink" title="命名socket的原因"></a>命名socket的原因</h1><p>创建socket时，我们为socket指定了地址族，但是未指定使用该地址族中的哪个具体的socket地址。所以需要通过socket命名来，将一个socket与一个socket地址绑定。另外，在服务器我们通常要命名socket，因为只有命名后，客户端才能知道该如何连接它。客户端则通常不需要命名socket，而是采用匿名的方式，即使用操作系统自动分配的socket地址。</p>
<p><strong>注意：socket地址包含了“协议、IP地址和端口号”这三要素，而命令则是通过调用bind把socket与这三要素绑定在一起</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建socket]]></title>
      <url>/2017/08/13/%E5%88%9B%E5%BB%BAsocket/</url>
      <content type="html"><![CDATA[<h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain,int type,int protocol);</span><br></pre></td></tr></table></figure>
<h1 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h1><ul>
<li>domain：告诉系统使用哪个底层协议族。（AF_INET,AF_INET6,AF_UNIX等）</li>
<li>type:   指定服务类型，包括SOCK_STREAM(字节流，TCP使用)、SOCK_DGRAM(数据报服务，UDP使用)等。另外在Linux内核版本为2.6.17版本起，type还可以接收刚才的两个服务类型和下面两个重要的标志相与的值：SOCK_NONBLOCK和SOCK_CLOEXEC。它们分别表示将创建一个新的socket设为非阻塞的，以及用fork创建子进程时，在子进程中关闭该socket。</li>
<li>protocol：一般设置为0。</li>
</ul>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>socket系统调用成功时，返回一个socket文件描述符，失败返回-1并设置errno。</p>
<p><strong>更为详细的socket系统调用可以参考其man手册</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[socket地址结构]]></title>
      <url>/2017/08/13/socket%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h1><p>socket网络编程接口中表示socket地址的是结构体sockaddr，其定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/socket.h&gt;</span><br><span class="line">struct sockaddr &#123;</span><br><span class="line">    sa_family_t  sa_family;</span><br><span class="line">    char sa_data[14];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sa_family成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型是对应的。</p>
<p><img src="http://i1.nbimg.com/593129/31040f22e71c3a6a.png" alt="image"></p>
<p>sa_data成员用于存放socket地址值，不同的协议族的地址值具有不同的含义和长度：</p>
<p><img src="http://i1.nbimg.com/593129/92146d66c1327539.png" alt="image"></p>
<h1 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h1><p>由于通用的socket地址在设置与获取IP和端口号时，需要执行烦锁的位操作，所以Linux为各个协议族提供了专门的socket地址结构体。</p>
<h2 id="UNIX本地域协议"><a href="#UNIX本地域协议" class="headerlink" title="UNIX本地域协议"></a>UNIX本地域协议</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/un.h&gt;</span><br><span class="line">struct sockaddr_un</span><br><span class="line">&#123;</span><br><span class="line">    sa_family_t sin_family;  /* 地址族：AF_UNIX */</span><br><span class="line">    char sun_path[108];      /* 文件路径名      */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t sin_family;    /*  地址族：AF_INET              */</span><br><span class="line">    u_in16_t sin_port;         /*  端口号，要用网络字节序表示   */ </span><br><span class="line">    struct in_addr sin_addr;   /*  IPv4地址结构体               */</span><br><span class="line">    char sin_zero[8];          /*  不使用字段，用于内存字节对齐 */ </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">struct in_addr&#123;</span><br><span class="line">    in_addr_t  s_addr;         /*  IPv4地址，要用网络字节序表示 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in6 &#123;</span><br><span class="line">    sa_family_t sin_family;      /*  地址族：AF_INET6           */</span><br><span class="line">    u_int16_t sin6_port;         /*  端口号：要用网络字节序表示 */</span><br><span class="line">    u_int32_t sin6_flowinfo;     /*  流信息：应设置为0          */</span><br><span class="line">    struct in6_addr sin6_addr;   /*  IPv6 地址结构体            */</span><br><span class="line">    u_int32_t sin6_scope_id;     /*  scope ID,尚处于实验阶段    */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct in6_addr &#123;</span><br><span class="line">    unsigned char sa_addr[16];   /*  IPv6地址，要用网络字节序   */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有专用socket地址类型在实际使用过程中，都必须转换为通过sock地址类型sockaddr，使用强制转换即可。因为所有的socket编程接口使用的socket地址参数的类型都是sockaddr。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络字节序与主机字节序转换函数和IP地址转换函数]]></title>
      <url>/2017/08/13/%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E5%92%8CIP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="网络字节序和主机字节序转换的函数"><a href="#网络字节序和主机字节序转换的函数" class="headerlink" title="网络字节序和主机字节序转换的函数"></a>网络字节序和主机字节序转换的函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;　　</span><br><span class="line">uint32_t htonl(uint32_t hostlong);//32位的主机字节序转换到网络字节序（IP地址转换）</span><br><span class="line">uint16_t htons(uint16_t hostshort);//16位的主机字节序转换到网络字节序(端口号转换)</span><br><span class="line">uint32_t ntohl(uint32_t netlong);//32位的网络字节序转换到主机字节序（IP地址转换）</span><br><span class="line">uint16_t ntohs(uint16_t netshort);//16位的网络字节序转换到主机字节序(端口号转换)</span><br></pre></td></tr></table></figure>
<h1 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">in_addr_t inet_addr(const char *cp);  /*  “点分十进制” －&gt; “整数”， */</span><br><span class="line">char *inet_ntoa(struct in_addr in);   /*  “整数” －&gt; “点分十进制”， */</span><br><span class="line">int inet_pton(int af, const char *src, void *dst);  /*  “点分十进制”－&gt; “整数”， */</span><br><span class="line">const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt);/*  “整数”－&gt;“点分十进制”*/</span><br></pre></td></tr></table></figure>
<h1 id="inet-addr和inet-ntoa"><a href="#inet-addr和inet-ntoa" class="headerlink" title="inet_addr和inet_ntoa"></a>inet_addr和inet_ntoa</h1><p>这两个函数只在IPv4中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in_addr_t  inet_addr(const char *cp);</span><br></pre></td></tr></table></figure>
<p>in_addr_t 即long型，参数cp表示一个点分十进制字符串，返回值是十进制长整型数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *inet_ntoa(struct in_addr in);</span><br></pre></td></tr></table></figure>
<p>参数in是一个in_addr类型的结构体，这个结构体原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    uint32_t s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ine_ntoa返回的是点分十进制的IP地址字符串。另外需要注意的是：inet_ntoa返回一个char指针,而这个char指针 的空间是在inet_ntoa里面静态分配的，所以inet_ntoa后面的调用会覆盖上一次的调用。</p>
<h1 id="inet-pton和inet-ntop"><a href="#inet-pton和inet-ntop" class="headerlink" title="inet_pton和inet_ntop"></a>inet_pton和inet_ntop</h1><p>这两个函数可以在IPv4和IPv6中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int inet_pton(int af, const char *src, void *dst);</span><br></pre></td></tr></table></figure>
<p>inet_pton 是 inet_addr 的扩展，支持的多地址族如下：</p>
<h3 id="af-AF-INET"><a href="#af-AF-INET" class="headerlink" title="af = AF_INET"></a>af = AF_INET</h3><p>src为存放了IPv4格式的地址的字符串，函数将该字符串转换为in_addr的结构体，并复制在dst中。</p>
<h3 id="af-AF-INET6"><a href="#af-AF-INET6" class="headerlink" title="af = AF_INET6"></a>af = AF_INET6</h3><p>src为存放了IPv6格式的地址的字符串址，函数将该地址转换为in6_addr的结构体，并复制在dst中。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果函数出错将返回一个负值，并将errno设置为EAFNOSUPPORT，如果参数af指定的地址族和src格式不对，函数将返回0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt);</span><br></pre></td></tr></table></figure>
<p>这个函数是将一个网络二进制结构转换为点分十进制，并且保存在字符串dst中，cnt表示dst的长度。如果dst太小无法存储地址的值，则返回一个空指针，并将errno置为ENOSPC。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[主机字节序列和网络字节序列]]></title>
      <url>/2017/08/13/%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="字节序列分类"><a href="#字节序列分类" class="headerlink" title="字节序列分类"></a>字节序列分类</h1><ol>
<li>大端法：高位字节存储在内存底地址处，低位字节存储在内存高地址处</li>
<li>小端法：高位字节存储在内存高地址处，低位字节存储在内存底地址处。</li>
</ol>
<h1 id="所谓的高地址和底地址"><a href="#所谓的高地址和底地址" class="headerlink" title="所谓的高地址和底地址"></a>所谓的高地址和底地址</h1><p>栈底 （高地址）</p>
<hr>
<p>buf[3]</p>
<p>buf[2]</p>
<p>buf[1]</p>
<p>buf[0]</p>
<hr>
<p>栈顶 （低地址）</p>
<h1 id="验证大小端的程序"><a href="#验证大小端的程序" class="headerlink" title="验证大小端的程序"></a>验证大小端的程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /* 使用了联合体的特性 */</span><br><span class="line">	union MyUnion</span><br><span class="line">	&#123;</span><br><span class="line">		short value;</span><br><span class="line">		char  buf[sizeof(short)];</span><br><span class="line">	&#125;test;</span><br><span class="line">	test.value = 0x0102;</span><br><span class="line"></span><br><span class="line">	if (test.buf[0] == 1 &amp;&amp; test.buf[1] == 2)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Big endian\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (test.buf[0] == 2 &amp;&amp; test.buf[1] == 1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Samll endian\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Unknow...\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现在PC机大多数采用的字节序是小端法，因此小端字节序又被称为主机字节序列。另外，发送端总是把数据转换为大端字节序列后再发送，而接收端知道收到的数据一定是大端字节序列，所以会根据自己的机器的字节序列选择是否进行字节序的转换，因此，我们把大端法称为网络字节序。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[各种排序算法的比较]]></title>
      <url>/2017/08/10/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《数据结构(C语言版)》  严蔚敏著</li>
</ul>
<h1 id="各种算法的时间复杂度和空间复杂度（参考链接）"><a href="#各种算法的时间复杂度和空间复杂度（参考链接）" class="headerlink" title="各种算法的时间复杂度和空间复杂度（参考链接）"></a>各种算法的时间复杂度和空间复杂度（<a href="http://www.jianshu.com/p/3f5528bd8fec" target="_blank" rel="noopener">参考链接</a>）</h1><p><img src="http://upload-images.jianshu.io/upload_images/2240277-e008c47f06d3de93?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h1 id="算法之间的比较与总结"><a href="#算法之间的比较与总结" class="headerlink" title="算法之间的比较与总结"></a>算法之间的比较与总结</h1><ol>
<li>从平均时间性能而言，快速排序最佳，其所需时间最省，但快速排序在最坏情况下时间性能不如堆排序和归并排序。而后两者相比较的结果是，在n较大时，归并排序所需要的时间更省，但是它需要的存储空间更多。</li>
<li>从方法的稳定性来比较，基数排序、直接插入排序和归并排序是稳定的，而性能较好的堆排序、希尔排序和快速排序是不稳定的。同时还有简单的选择排序也是不稳定的。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>排序算法在面试和实际的编程中都会有很大的用处，所以《排序算法》这个系列主要的目的就是为了方便自己以后需要的时候查询。</p>
<p>附上每篇博客介绍的算法：</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><a href="https://ouyanglianjun.github.io/2017/05/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">选择排序</a></h2><ul>
<li>简单选择排序</li>
<li>堆排序</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><a href="https://ouyanglianjun.github.io/2017/08/07/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">插入排序</a></h2><ul>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>希尔排序</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><a href="https://ouyanglianjun.github.io/2017/08/09/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">快速排序</a></h2><ul>
<li>快速排序</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><a href="https://ouyanglianjun.github.io/2017/08/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">归并排序</a></h2><ul>
<li>归并排序</li>
</ul>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><a href="https://ouyanglianjun.github.io/2017/08/10/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">基数排序</a></h2><ul>
<li>基数排序</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基数排序]]></title>
      <url>/2017/08/10/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>基数排序是将所有的待排数据（只能是正整数）的位数统一，数位较短的数据需要在开头补零。然后，从最低位开始，依次进行排序，这样从最低位一直到最高位依次进行排序后，就可以得到一个有序的数列。</p>
<h1 id="图示（参考链接）"><a href="#图示（参考链接）" class="headerlink" title="图示（参考链接）"></a>图示（<a href="http://gaunthan.leanote.com/post/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F#title-1" target="_blank" rel="noopener">参考链接</a>）</h1><p><img src="https://leanote.com/api/file/getImage?fileId=58c7c71dab64417e39002b14" alt="image"></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">/*</span><br><span class="line"> * 寻找位数的最大值</span><br><span class="line"> */</span><br><span class="line">int max_bit(int * data, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int bit = 0;</span><br><span class="line">	int i = 0;</span><br><span class="line">	for (i = 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int bit_temp = 0;</span><br><span class="line">		int temp = data[i];</span><br><span class="line">		while (1)</span><br><span class="line">		&#123;</span><br><span class="line">			if ( (temp / 10) == 0 &amp;&amp; temp == 0)</span><br><span class="line">				break;</span><br><span class="line">			bit_temp++;</span><br><span class="line">			temp = temp / 10;	</span><br><span class="line">		&#125;</span><br><span class="line">		if (bit_temp &gt; bit)</span><br><span class="line">			bit = bit_temp;</span><br><span class="line">	&#125;</span><br><span class="line">	return bit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 基数排序</span><br><span class="line"> */</span><br><span class="line">void RadixSort(int * data, int len)</span><br><span class="line">&#123;</span><br><span class="line">	//得到最大位数值</span><br><span class="line">	int bit = max_bit(data,len);</span><br><span class="line">	int r = 1;</span><br><span class="line">	int count[10];</span><br><span class="line">	int * tmp = (int *)calloc(len,sizeof(int));</span><br><span class="line">	//对每个位上的数进行排序</span><br><span class="line">	int i = 0;</span><br><span class="line">	int index = 0;</span><br><span class="line">	printf(&quot;bit = %d\n&quot;, bit);</span><br><span class="line">	for (index = 0; index &lt; bit; index++)</span><br><span class="line">	&#123;</span><br><span class="line">		//装桶之前要先清桶</span><br><span class="line">		memset(count, 0, 10*sizeof(int));</span><br><span class="line">		for (i = 0; i &lt; len; i++) //记录每个桶的记录数</span><br><span class="line">		&#123;</span><br><span class="line">			int k = data[i] / r;</span><br><span class="line">			int q = k % 10;     </span><br><span class="line">			count[q]++;</span><br><span class="line">		&#125;</span><br><span class="line">		//为存储桶里的数据腾出足够的空间，这样好存储。</span><br><span class="line">		//通过画图可以容易理解这个循环的含义</span><br><span class="line">		for (i = 1; i &lt; 10; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			count[i] += count[i - 1];</span><br><span class="line">		&#125;</span><br><span class="line">		//这个循环从后往前走是为了保证数据的稳定性，</span><br><span class="line">		//因为每个桶里的数据都是从该桶底部往上存放的</span><br><span class="line">		for (int j = len - 1; j &gt;= 0; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			int p = data[j] / r;</span><br><span class="line">			int s = p % 10;</span><br><span class="line">			tmp[count[s] - 1] = data[j];</span><br><span class="line">			count[s]--;</span><br><span class="line">		&#125;</span><br><span class="line">		//将排好的数据复制回去</span><br><span class="line">		for (i = 0; i&lt;len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			data[i] = tmp[i];</span><br><span class="line">			printf(&quot;%d,&quot;, data[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		r = r * 10;                //从个位开始，依次往前走</span><br><span class="line">	&#125;</span><br><span class="line">	free(tmp);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int data[] = &#123; 329, 457, 657, 839, 436, 720, 355 &#125;;</span><br><span class="line">	RadixSort(data, 7);</span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; i &lt; 7; i++)</span><br><span class="line">		printf(&quot;%d,&quot;, data[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>通过代码实现，我们可以知道算法的时间复杂度为：O(k * n).其中k为位数最长的值，n为元素的个数。</p>
]]></content>
      
        
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[归并排序]]></title>
      <url>/2017/08/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们这里介绍的是二路归并算法，它的核心是将一维数组中前后的两个有序的序列合并成一个有序序列的过程。归并排序只需要做两将事情：</p>
<ol>
<li>“分解”——将序列每次折半划分</li>
<li>“合并”——将划分后的序列段两两合并成有序序列。</li>
</ol>
<h1 id="图示（参考链接）"><a href="#图示（参考链接）" class="headerlink" title="图示（参考链接）"></a>图示（<a href="http://blog.csdn.net/yinjiabin/article/details/8265827/" target="_blank" rel="noopener">参考链接</a>）</h1><p><img src="http://images.cnblogs.com/cnblogs_com/flyingbread/MergeSort.jpg" alt="image"></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void Merge(int * a, int temp[], int low, int mid, int high)</span><br><span class="line">&#123;</span><br><span class="line">	int low_s = low;</span><br><span class="line">	int low_e = mid;</span><br><span class="line">	int high_s = mid + 1;</span><br><span class="line">	int high_e = high;</span><br><span class="line">	int k = 0;</span><br><span class="line">	while (low_s &lt;= low_e &amp;&amp; high_s &lt;= high_e)    //通过归并进行排序，这个思路很重要</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[low_s] &lt; a[high_s])</span><br><span class="line">		&#123;</span><br><span class="line">			temp[k++] = a[low_s++];</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			temp[k++] = a[high_s++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (low_s &lt;= low_e)   temp[k++] = a[low_s++];</span><br><span class="line">	while (high_s &lt;= high_e) temp[k++] = a[high_s++];</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[low + i] = temp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Msort(int * a, int temp[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">	if (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		int mid = (low + high) / 2;      //中间下标</span><br><span class="line">		Msort(a, temp, low, mid);        //对左边进行递归分割</span><br><span class="line">		Msort(a, temp, mid + 1, high);   //对右边进行递归分割</span><br><span class="line">		Merge(a, temp, low, mid, high);  //合并前面两个有序的序列</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int temp[6];</span><br><span class="line">	int a[] = &#123; 14, 12, 15, 13, 11, 16 &#125;;</span><br><span class="line">	Msort(a, temp, 0, 5);</span><br><span class="line">	for (int i = 0; i &lt; 6; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d,&quot;, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N<em>logN)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(N</em>logN)的几种排序方法（<a href="https://ouyanglianjun.github.io/2017/08/09/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">快速排序</a>，归并排序，<a href="https://ouyanglianjun.github.io/2017/05/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">堆排序</a>）也是效率比较高的。但是平均来说还是<a href="https://ouyanglianjun.github.io/2017/08/09/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">快速排序</a>比较好。</p>
]]></content>
      
        
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>/2017/08/09/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>1、先从数列中取出一个数作为基数<br>2、根据该基数进行分区，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。（升序）<br>3、再对左右两个部分重复前面两个步骤，直至区间中元素个数为1.</p>
<h1 id="图示（参考链接）"><a href="#图示（参考链接）" class="headerlink" title="图示（参考链接）"></a>图示（<a href="http://blog.sina.com.cn/s/blog_8898a00d0102whmd.html" target="_blank" rel="noopener">参考链接</a>）</h1><p><img src="http://s4.sinaimg.cn/mw690/002v5KQRgy70D62vRdh33" alt="image"></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int Partition(int *a, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">	/* 这里的基数我们取的第一个数 */</span><br><span class="line">	int temp = a[low];  </span><br><span class="line">	while (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		while (low &lt; high &amp;&amp;a[high] &gt;= temp) --high;</span><br><span class="line">		a[low] = a[high];</span><br><span class="line">		while ( low &lt; high &amp;&amp; a[low] &lt;= temp) ++low;</span><br><span class="line">		a[high] = a[low];</span><br><span class="line">	&#125;</span><br><span class="line">	a[low] = temp;</span><br><span class="line">	return low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Q_sort(int * a, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">	if (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		/* 根据函数Partition，对数列进行分去，并且返回基数最后存放的位置 */</span><br><span class="line">		int position = Partition(a, low, high);</span><br><span class="line">		/* 递归 */</span><br><span class="line">		Q_sort(a, low, position - 1);</span><br><span class="line">		Q_sort(a, position + 1, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[] = &#123; 84, 83, 88, 87, 61, 50, 70, 60, 80, 99 &#125;;</span><br><span class="line">	Q_sort(a, 0, 9);</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d,&quot;, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>算法的平均时间复杂为：O（n * log N）;</p>
<p>最坏的情况：<br>对n个元素的区间进行划分时，得到的两个子区间含有的元素分别为：0个和n-1个。假设算法每一次递归调用过程中都出现了这种不对称划分。那么划分的代价为O（n），因此可以估计其时间复杂度为：O(n^2)。</p>
<p>其实快速排序的最坏的情况是对有序或基本有序的数列进行排序时出现的，此时其本质已经退化为冒泡排序了。另外，快速排序还有很多改进版，如随机选择基数，区间内数据较少时直接用另外的方法排序以减小递归深度等。</p>
]]></content>
      
        
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[插入排序]]></title>
      <url>/2017/08/07/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="插入排序介绍"><a href="#插入排序介绍" class="headerlink" title="插入排序介绍"></a>插入排序介绍</h1><ul>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>希尔排序</li>
</ul>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>n个待排数据存放在a[n]中。开始时，a[0]为唯一的有序数据，a[1]~a[n-1]为n-1个无序数据。排序过程都是取出无序数据中的第一个数据插入到前面已经有序的数据中，这样经过了n-1次插入后，完成排序工作。</p>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="http://img.blog.csdn.net/20170426193257383?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTc4NDQ5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;;</span><br><span class="line"></span><br><span class="line">	int i = 1;</span><br><span class="line">	int j = 0;</span><br><span class="line">	int temp = 0;</span><br><span class="line">	for (i = 1; i &lt; 8; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[i - 1] &gt; a[i])     /* a[i] &gt; a[i -1]，此时已经有序，无序排序 */</span><br><span class="line">		&#123;</span><br><span class="line">		    //取出第一个数据</span><br><span class="line">			temp = a[i];</span><br><span class="line">			//寻找插入位置</span><br><span class="line">			for (j = i - 1; temp &lt; a[j] &amp;&amp; j &gt;= 0; --j)</span><br><span class="line">			&#123;</span><br><span class="line">			     /* 将数据往后移动，给需要插入的那个数腾个空间 */</span><br><span class="line">				a[j + 1] = a[j];      </span><br><span class="line">			&#125;</span><br><span class="line">			a[j + 1] = temp;          /* 插入到合适的位置  */</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; 8; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d,&quot;, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>最好情况为正序的时候，最坏情况为逆序的时候。时间复杂度为o(n*n)。</p>
<h1 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>在前面直接插入排序的基础上，优化了寻找插入位置段的代码，通过折半查找的方式查找插入位置，来寻找插入的位置。</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;;</span><br><span class="line"></span><br><span class="line">	int i = 1;</span><br><span class="line">	int j = 0;</span><br><span class="line">	int temp = 0;</span><br><span class="line">	int high = 0;</span><br><span class="line">	int low = 0;</span><br><span class="line">	int mid = 0;</span><br><span class="line">	for (i = 1; i &lt; 8; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[i - 1] &gt; a[i])     /* a[i] &gt; a[i -1]，此时已经有序，无序排序 */</span><br><span class="line">		&#123;</span><br><span class="line">			temp = a[i];</span><br><span class="line">			high = i - 1;</span><br><span class="line">			low = 0;</span><br><span class="line">			while (low &lt;= high) //折半查找插入的位置</span><br><span class="line">			&#123;</span><br><span class="line">				mid = low + (high - low) / 2;</span><br><span class="line"></span><br><span class="line">				if (temp &lt; a[mid])</span><br><span class="line">				&#123;</span><br><span class="line">					high = mid - 1;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					low = mid + 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			/* 将数组的内容后移 */</span><br><span class="line">			for (j = i; j &gt; low; --j)</span><br><span class="line">			&#123;</span><br><span class="line">				a[j] = a[j - 1];</span><br><span class="line">			&#125;</span><br><span class="line">			a[low] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i = 0; i &lt; 8; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d,&quot;, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><p>折半插入排序优化了最坏的情况下的比较次数，但是还是记录的移动次数是没有减少的，所以其时间复杂度还是：O(n*n)</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>先将整个待排记录序列分割成若干个序列分别进行直接插入排序，待整个序列的记录“基本有序”时，再对全体进行一次直接插入排序。</p>
<h2 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h2><p>把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到1时，整个数据合成为一组，构成一组有序记录，则完成排序。</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1502100641541&amp;di=beb625bcf0b981624ad869346bdf632e&amp;imgtype=0&amp;src=http%3A%2F%2Fs4.sinaimg.cn%2Fmw690%2F002v5KQRgy70D3Q2GpZ83" alt="image"></p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/* 直接插入排序 */</span><br><span class="line">void insert_sort(int *a, int start, int gap,int len)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	int j = 0;</span><br><span class="line">	int temp = 0;</span><br><span class="line">	for (i = start + gap; i &lt; len; i = i + gap)          /* 步长为gap */</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[i - gap] &gt; a[i])</span><br><span class="line">		&#123;</span><br><span class="line">			temp = a[i];</span><br><span class="line"></span><br><span class="line">			for (j = i - gap; j &gt;= start &amp;&amp; temp &lt; a[j]; j = j - gap)   //这个注意我们是从start开始的</span><br><span class="line">			&#123;</span><br><span class="line">				a[j + gap] = a[j];</span><br><span class="line">			&#125;</span><br><span class="line">			a[j + gap] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sort(int * a, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int start = 0;</span><br><span class="line">	int gap = 0;</span><br><span class="line">	int i = 0;</span><br><span class="line">	for (gap = len / 2; gap &gt; 0; gap = gap / 2)    /* 几趟希尔排序 */</span><br><span class="line">	&#123;</span><br><span class="line">		for (start = 0; start &lt; gap; start++)      /* gap为组数，对每组进行直接插入排序*/</span><br><span class="line">		&#123;</span><br><span class="line">			insert_sort(a, start, gap, len);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[] = &#123; 84, 83, 88, 87, 61, 50, 70, 60, 80, 99 &#125;;</span><br><span class="line">    int i = 0;</span><br><span class="line">	sort(a, 10);</span><br><span class="line">	for (i = 0; i &lt; 10; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d,&quot;, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h2><p>希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。我们上面选择的增量序列{n/2,(n/2)/2…1}(希尔增量)，其最坏时间复杂度依然为O(n*n)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n^1.5)。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天学习了三种排序算法，其中希尔排序算法在性能上是最好的，希尔排序算法是直接插入排序算法的一种改进，减少了其复制的次数，速度要快很多，原因是，当n值很大时数据项每一趟排序需要的个数很少，但数据项的距离很长。当n值减小时每一趟需要和动的数据增多，此时已经接近于它们排序后的最终位置。正是这两种情况的结合才使希尔排序效率比插入排序高很多。</p>
<p>参考：</p>
<p><a href="http://blog.sina.com.cn/s/blog_8898a00d0102whmd.html" target="_blank" rel="noopener">动态参考</a><br><a href="http://blog.csdn.net/u011784495/article/details/70832358" target="_blank" rel="noopener">博客参考</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[控制报文协议ICMP]]></title>
      <url>/2017/08/06/%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP/</url>
      <content type="html"><![CDATA[<h1 id="ICMP协议的简介"><a href="#ICMP协议的简介" class="headerlink" title="ICMP协议的简介"></a>ICMP协议的简介</h1><p>ICMP协议是IP协议的补充，用于IP层的差错报告、拥塞控制、路径控制以及路由器或主机信息的获取。ICMP与IP协议位于同一个层次（IP层），但ICMP报文是封装在IP数据报的数据部分进行传输的。</p>
<h1 id="ICMP数据报的格式"><a href="#ICMP数据报的格式" class="headerlink" title="ICMP数据报的格式"></a>ICMP数据报的格式</h1><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1501995227178&amp;di=b4d706f312b22798207b8c3a9fd8fded&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.myexception.cn%2Fimg%2F2012%2F08%2F19%2F214315226.jpg" alt="image"></p>
<h1 id="ICMP数据报各个字段的含义"><a href="#ICMP数据报各个字段的含义" class="headerlink" title="ICMP数据报各个字段的含义"></a>ICMP数据报各个字段的含义</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>定义了ICMP报文的类型。ICMP报文的类型答题可以分为两类：差错报文和查询报文，具体的消息类型如下：</p>
<p><img src="http://i4.bvimg.com/1949/33d5396ca60b9b05.png" alt="image"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>标识发送特定报文的原因，从上图可以看到有的ICMP报文类型字段相同，需要code来区分具体的原因。</p>
<h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>提供ICMP整个报文的校验和。</p>
<h2 id="首部其余部分"><a href="#首部其余部分" class="headerlink" title="首部其余部分"></a>首部其余部分</h2><p>由报文类型确定内容，大部分差错报文未使用该字段。</p>
<h2 id="数据部分"><a href="#数据部分" class="headerlink" title="数据部分"></a>数据部分</h2><p>提供ICMP差错和状态报告信息，内容因报文类型而异。</p>
<h1 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h1><h2 id="目的站不可到达报文"><a href="#目的站不可到达报文" class="headerlink" title="目的站不可到达报文"></a>目的站不可到达报文</h2><p>当路由器不能找到正确的路由器或者主机完成IP数据报的转发时，则会丢弃该报文，并且路由器会向源主机发出ICMP目的站不可达报文。此报文的类型字段的值为3，其他字段的内容如下：</p>
<p><img src="http://i4.bvimg.com/1949/340ed3bd2217f607.png" alt="image"></p>
<h2 id="源站的抑制报文"><a href="#源站的抑制报文" class="headerlink" title="源站的抑制报文"></a>源站的抑制报文</h2><p>当路由器或主机因为拥塞而丢弃IP数据报时，就向报文的发送站发送源站抑制报文。此报文的类型字段的值为4，其他字段的内容如下：</p>
<p><img src="http://i4.bvimg.com/1949/75ceda734cd47fae.png" alt="image"></p>
<h2 id="路由重定向报文"><a href="#路由重定向报文" class="headerlink" title="路由重定向报文"></a>路由重定向报文</h2><p>路由器转发分组过程中，要将最有效的路由信息告知源主机，更新源主机路由表。该路由信息是路由器通过向源主机发送路由定向报文。此报文的类型字段的值为5，其他字段的内容如下：</p>
<p><img src="http://i4.bvimg.com/1949/213dadb34c26f204.png" alt="image"></p>
<h2 id="超时报文"><a href="#超时报文" class="headerlink" title="超时报文"></a>超时报文</h2><p>如果路由器遇到一个IP数据报中的生存期字段（TTL）为0的报文，则会将它丢弃，并且向其发送源发送一个ICMP超时报文。此报文的类型字段的值为11，其他字段的内容如下：</p>
<p><img src="http://i2.bvimg.com/1949/ac42f643391298d1.png" alt="image"></p>
<h2 id="参数出错报文"><a href="#参数出错报文" class="headerlink" title="参数出错报文"></a>参数出错报文</h2><p>当IP分组头中任何一项接收出错时，路由器是无法处理，只能将该分组丢弃。并向发送端发送ICMP参数出错报文。此报文的类型字段的值为12，其他字段的内容如下：</p>
<p><img src="http://i1.bvimg.com/1949/e13f54b324956ec7.png" alt="image"></p>
<h1 id="ICMP查询报文"><a href="#ICMP查询报文" class="headerlink" title="ICMP查询报文"></a>ICMP查询报文</h1><p>ICMP查询报文的目的是实现对网络故障进行诊断和控制。在ICMP查询报文是双向的，成对出现，而ICMP差错控制报文只是单向的。</p>
<h2 id="回应请求与应答"><a href="#回应请求与应答" class="headerlink" title="回应请求与应答"></a>回应请求与应答</h2><p>测试能否到达目的主机/路由器（网络连通性）由主机发出请求，检查另一个主机能否可达（ping命令）。其中类型的值为8的为ICMP回应请求报文，类型为0的是ICMP回应应答报文。其报文具体内容如下：</p>
<p><img src="http://i1.bvimg.com/1949/8a6b49ed4724c404.png" alt="image"></p>
<p>除此之外，还有其他几种查询报文，可以自行查阅资料，这里就只介绍了常用的查询报文。</p>
<h1 id="ICMP报文封装图"><a href="#ICMP报文封装图" class="headerlink" title="ICMP报文封装图"></a>ICMP报文封装图</h1><p>ICMP报文作为IP分组数据转发（被封装在IP分组的数据段中），包含ICMP报文的IP分组头的协议类型字段值设为：1，其封装过程如下：</p>
<p><img src="http://i4.bvimg.com/1949/f6c6314c545d80a7.png" alt="image"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ICMP协议是封装到IP分组的数据中进行传输，它是对IP协议的一个补充。它包含两大类报文：ICMP差错报文、ICMP查询报文</p>
]]></content>
      
        
        <tags>
            
            <tag> IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPv4数据报的结构]]></title>
      <url>/2017/08/06/IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="IPv4分组结构"><a href="#IPv4分组结构" class="headerlink" title="IPv4分组结构"></a>IPv4分组结构</h1><p><img src="http://s4.51cto.com/wyfs01/M00/0F/8D/wKioOVHHxpWzgas9AABxpz3b1y0968.jpg" alt="image"></p>
<h1 id="IPv4各个字段的含义"><a href="#IPv4各个字段的含义" class="headerlink" title="IPv4各个字段的含义"></a>IPv4各个字段的含义</h1><ul>
<li>4位版本号</li>
</ul>
<p>版本字段值为4，表示IPv4<br>版本字段值为6，表示IPv6</p>
<ul>
<li>4位头部长度</li>
</ul>
<p>表示IPv4头部的长度，不包括数据部分。它的单位为4字节，所以可以表示的最大长度为6<br>0字节。而IPv4数据报前20个字节的字段是必须的，所头部长度的最小值为5，最大值为15。</p>
<ul>
<li>服务类型</li>
</ul>
<p>8位服务类型包含3位优先权字段（已经被忽略），4位的TOS字段和1位保留字段（保留字<br>段必须置0）。4位的TOS字段分别表示：最小延时、最大吞吐量、最高可靠性和最小费用<br>。其中最多一个能置1.。比如像ssh和Telnet这样的登录程序需要最小延时的服务，而文<br>件传输程序需要最大吞吐量的服务。</p>
<ul>
<li>16位总长度（字节为单位）</li>
</ul>
<p>这个字段表示的是整个IPv4数据报的长度（头部和数据之和）。由于有16位字段可以表示<br>的最大长度为：65535字节，但是受到MTU的限制，则超过MTU部分会被分片传输</p>
<ul>
<li>16位标识</li>
</ul>
<p>16位标识唯一标识主机发送的每一个数据报。其初始值由系统随机生成；每发送一个数据<br>报，其值加1。该值在数据报分片传输时，被复制到每个分片中，因此同一数据报的所<br>有分片都具有相同的标识值。</p>
<ul>
<li>3位的标志字段</li>
</ul>
<p>第一位保留，第二位（Don’t<br>FragmentDF）表示不要分片。如果该位被置1，IP模块将不对数据报进行分片，如果数据<br>报超出了MTU，则会被丢弃并且返回ICMP数据报给发送端。第三位(More Fragment<br>MF),表示更多分片，除了数据报的最后一个分片外，其他分片都要把它置1。</p>
<ul>
<li>13位偏移</li>
</ul>
<p>这个偏移是指当前分片的偏移是相对于原始IP数据报的开始处（仅指数据部分）的偏移。<br>实际的偏移值是该值左移3位（乘8）后得到的值。正是由于这个原因，除了最后一个IP分<br>片外，其他的每个分片的数据部分的长度都要为8的倍数。</p>
<ul>
<li>8位生存时间</li>
</ul>
<p>8位的生存值（Time To Live  TTL）是数据报到达目的之前允许经过的路由器跳数。TTL值被发送端设置（通常设置为64<br>）。数据报在转发过程中，每经过一个路由器，该值就减一，但TTL的值减为0时，数据报<br>就被丢弃，并返回一个ICMP数据报给发送端。</p>
<ul>
<li>8协议字段</li>
</ul>
<p>这字段用来区分上层所使用的协议，1代表ICMP，6代表TCP，17代表UDP，89代表OSPF</p>
<ul>
<li>头部检验和</li>
</ul>
<p>16位头部校验和由发送端填充，接收端对其使用CRC算法以检验IP数据报头部（注意：只是检查头部），在传输过程中是否被损坏</p>
<ul>
<li>源IP地址和目的IP地址</li>
</ul>
<p>这两个字段都是由发送端填充。</p>
<ul>
<li>选项字段</li>
</ul>
<p>IPv4最后一个选项字段（option）是可变长的可选信息。这部分最多包含40字节，因为IP<br>头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。可用的IP选项包括：</p>
<ol>
<li>记录路由（record route），告诉数据报途经的所有路由器都将自己的IP地址填入IP<br>头部的选项部分，这样我们就可以跟踪数据报的传递路径。</li>
<li>时间戳（timestamp），告诉每个路由器都将数据报被转发的时间（或时间与IP地址对）填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间。</li>
<li>松散源路由选择（loose source routing），指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器。</li>
<li>严格源路由选择（strict source routing），和松散源路由选择类似，不过数据报只能经过被指定的路由器。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇博客介绍了IPv4的数据报的布局以及各个字段的含义，这个对我们去了解后续介绍的网络层方面的知识是很有帮助的。</p>
]]></content>
      
        
        <tags>
            
            <tag> IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenStack入门介绍]]></title>
      <url>/2017/07/22/OpenStack%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>参考：<a href="http://www.cnblogs.com/pythonxiaohu/p/5861409.html" target="_blank" rel="noopener">原文链接</a></p>
<h1 id="1、为啥要选择云计算"><a href="#1、为啥要选择云计算" class="headerlink" title="1、为啥要选择云计算"></a>1、为啥要选择云计算</h1><h2 id="（1）有效的解决了硬件单节点故障问题"><a href="#（1）有效的解决了硬件单节点故障问题" class="headerlink" title="（1）有效的解决了硬件单节点故障问题"></a>（1）有效的解决了硬件单节点故障问题</h2><p>单点故障是指某个硬件的故障造成网站某个服务的中断。要真正解决这个问题，需要为每个硬件准备冗余，这不仅大大增加了硬件购置成本，而且部署与维护成本也不容小视。而云计算平台是基于服务器集群，从设计之初就考虑了单点故障问题，并在建设时有效地解决了这个问题。如果一家云服务商出现单点故障问题，就如同存在银行的钱丢了。</p>
<h2 id="（2）按需增减资源"><a href="#（2）按需增减资源" class="headerlink" title="（2）按需增减资源"></a>（2）按需增减资源</h2><p>自己托管服务器，增/减硬件一直是头疼的问题。</p>
<pre><code>1. 增加服务器的时候，购买服务器需要时间，而且这个时间自己无法控制。而使
   用云服务器，随时可以增加服务器——垂手可得。
2. 减服务器只能从机房拉回办公室，无法再把服务器退给厂商，购置服务器的成
   本就浪费了。而使用云服务器，如果下个月不用，不续费就行了（针对阿里云按月购买的情况）——想用就用，想扔就扔。
3. 不能按需增加满足基本需求的服务器配置。假如我们现在需要一台低配置的服务
   器用Linux跑缓存服务，如果为之单独购买一台便宜的低配置的服务器很不合算，因为这台服务器仅仅一年的电费就至少要3000元左右。所以只能尽量减少
    服务器数量，提高单台服务器的配置，在让一台服务器跑更多东西。而使用云服务器，需要什么样的配置就买什么样的配置，让各个服务器的职责更单
    一，互相之间的影响更小——职责分明，效率更高。
</code></pre><h2 id="（3）BGP线路解决南北互通问题"><a href="#（3）BGP线路解决南北互通问题" class="headerlink" title="（3）BGP线路解决南北互通问题"></a>（3）BGP线路解决南北互通问题</h2><p>南北互通问题是南方电信与北方联通线路之间的互通问题，这个问题困扰我们多年，之前用过双线机房，解决的也不是很好。目前只有BGP线路才能有效解决这个问题，而拥有真正的BGP线路的机房不是很多，成本也非常高。而我准备使用的阿里云用的就是BGP线路，这也是吸引我们的主要地方之一。<br>    究竟什么是南北互通问题？基于我们的理解简体描述一下，不对之处欢迎指出。南北互通问题实际就是路由问题。假设我们的服务器放在上海电信的机房，上海一位联通的用户访问我们的服务器，要先绕到联通的北京总出口（假设总出口在北京），然后再绕回上海。实际上这位联通用户可以通过上海的线路直接到达我们的服务器，不用绕这么远，但上海电信的机房无法告知联通的路由器走近路过来，只能按照联通路由器设定好的路由走。本来即使走北京绕一下也没有大的影响，毕竟是光的速度，但是由于大多数联通的用户访问电信网络都这么绕着走，联通的总出口成为了瓶颈，总出口流量太大时，联通的用户访问电信的网络速度就会慢。BGP线路也没什么神奇之处，只是它能决定走什么路由过来，不绕远路，问题自然解决了。它有这样的特权，就不仅能解决南北互通的问题，而且能解决其他网络的互通问题，比如教育网。因为有权限决定路由，就可以优化路由，哪条路堵，我就换条路。</p>
<h2 id="（4）按需增减带宽"><a href="#（4）按需增减带宽" class="headerlink" title="（4）按需增减带宽"></a>（4）按需增减带宽</h2><p>带宽是主要成本，托管服务器时，与ISP服务商签一年合同之前就要确定带宽。用了一段时间之后，你发现带宽买多了，想减一些是不允许的。中途要临时增加带宽一段时间也是不行的，要买就买一年（这是根据我们接触过的ISP服务商）。所以，一般都会多买一些带宽，留一些余量。<br>    使用云服务器可以灵活地增减带宽，不会浪费带宽，即使买少了也不用担心，随时可以增加。虽然各个云服务商会有一定的限制，比如在阿里云一次至少要购买1个月的带宽，但比自己托管服务器灵活很多，同样的带宽条件，会节省不少成本，尤其是带宽需求在一年中变化比较大的网站。</p>
<h2 id="（5）更为合理的支付方式"><a href="#（5）更为合理的支付方式" class="headerlink" title="（5）更为合理的支付方式"></a>（5）更为合理的支付方式</h2><p>在IDC机房托管服务器一般是签一年合同，一次支付一个季度的费用。<br>    而使用云服务，一次可以支付更短时间的费用，比如阿里云可以一次只支付一个月的费用，节约了流动资金。<br>    从总体上考虑，差不多的成本，却拥有更多的内存、更多的CPU、更多的硬盘空间、更优质的带宽线路，更重要的是可以随时按需扩展计算资源。</p>
<h1 id="2、云计算服务模式"><a href="#2、云计算服务模式" class="headerlink" title="2、云计算服务模式"></a>2、云计算服务模式</h1><h2 id="（1）laaS：基础设施即服务"><a href="#（1）laaS：基础设施即服务" class="headerlink" title="（1）laaS：基础设施即服务"></a>（1）laaS：基础设施即服务</h2><p>用户通过网络获取虚机、存储、网络，然后用户根据自己的需求操作获取的资源。  典型应用：亚马逊AWS等</p>
<h2 id="（2）Paas：平台即服务"><a href="#（2）Paas：平台即服务" class="headerlink" title="（2）Paas：平台即服务"></a>（2）Paas：平台即服务</h2><p> 将软件研发平台作为一种服务， 如Eclipse/Java编程平台，服务商提供编程接口/运行平台等。典型应用：Google AppEngine、Force.com、微软Azure等 </p>
<h2 id="（3）SaaS：软件即服务"><a href="#（3）SaaS：软件即服务" class="headerlink" title="（3）SaaS：软件即服务"></a>（3）SaaS：软件即服务</h2><p>   将软件作为一种服务通过网络提供给用户，如web的电子邮件、HR系统、订单管理系统、客户关系系统等。用户无需购买软件，而是向提供商租用基于web的软件，来管理企业经营活动。典型应用：Google Doc、Saleforce.com、Oracle CRM On Demand、Office Live Workspace等</p>
<h1 id="3、openstack组件到介绍"><a href="#3、openstack组件到介绍" class="headerlink" title="3、openstack组件到介绍"></a>3、openstack组件到介绍</h1><h2 id="（1）openstack的由来"><a href="#（1）openstack的由来" class="headerlink" title="（1）openstack的由来"></a>（1）openstack的由来</h2><p>openstack最早由美国国家航空航天局NASA研发的Nova和Rackspace研发的swift组成。后来以apache许可证授权,旨在为公共及私有云平台建设。openstack主要用来为企业内部实现类似于Amazon EC2和S3的云基础架构服务（Iaas）.每6个月更新一次，基本与ubuntu同步，命名是以A-Z作为首字母来的。</p>
<h2 id="（2）openstack项目与组件"><a href="#（2）openstack项目与组件" class="headerlink" title="（2）openstack项目与组件"></a>（2）openstack项目与组件</h2><h3 id="核心项目3个"><a href="#核心项目3个" class="headerlink" title="核心项目3个"></a>核心项目3个</h3><h4 id="1、控制台"><a href="#1、控制台" class="headerlink" title="1、控制台"></a>1、控制台</h4><p>服务名：Dashboard<br>项目名：Horizon<br>功能    ：web方式管理云平台，建立主机、分配网络，配安全组，加云盘</p>
<h4 id="2、计算"><a href="#2、计算" class="headerlink" title="2、计算"></a>2、计算</h4><p>服务名：Compute<br>项目名：Nova<br>功能    ：负责响应虚拟机创建请求、调度、销毁</p>
<h4 id="3、网络"><a href="#3、网络" class="headerlink" title="3、网络"></a>3、网络</h4><p>服务名：Network<br>项目名：Neutron （从Quantum改名而来的）<br>功能    ：在各接口设备之间提供网络即服务(networking as a service),而且受其他OpenStack服务管理,如Nova。 具体来说，Neutron为OpenStack云更灵活地划分物理网络，在多租户环境下提供给每个租户独立的网络环境。另外，Neutron提供API来实现这种目标。Neutron中“网络”是一个可以被用户创建的对象，如果要和物理环境下的概念映射的话，这个对象相当于一个巨大的交换机，可以拥有无限多个动态可创建和销毁的虚拟端口。</p>
<h3 id="存储项目2个"><a href="#存储项目2个" class="headerlink" title="存储项目2个"></a>存储项目2个</h3><h3 id="1、对象存储"><a href="#1、对象存储" class="headerlink" title="1、对象存储"></a>1、对象存储</h3><p>服务名：Object Storage<br>项目名：Swift<br>功能    ：<br>REST风格的接口和扁平的数据组织结构。RESTFUL HTTP API来保存和访问任意非结构化数据，ring环的方式实现数据自动复制和高度可以扩展架构，保证数据的高度容错和可靠性</p>
<h4 id="2、块存储"><a href="#2、块存储" class="headerlink" title="2、块存储"></a>2、块存储</h4><p>服务名：Block Storage<br>项目名：Cinder<br>功能：提供持久化块存储，也就为云主机提共附加的云盘</p>
<h3 id="共享服务项目："><a href="#共享服务项目：" class="headerlink" title="共享服务项目："></a>共享服务项目：</h3><h4 id="1、认证服务"><a href="#1、认证服务" class="headerlink" title="1、认证服务"></a>1、认证服务</h4><p>服务名：认证服务<br>项目名：KeySton<br>功能    ：为访问openstack各组件提供认证和授权功能，认证通过后，提供一个服务列表（罗列你有权限访问的服务）。</p>
<h4 id="2、镜像服务"><a href="#2、镜像服务" class="headerlink" title="2、镜像服务"></a>2、镜像服务</h4><p>服务名：镜像服务<br>项目名：Glance<br>功能    ：为云主机安装操作系统提供不同的镜像选择</p>
<h4 id="3、计费服务"><a href="#3、计费服务" class="headerlink" title="3、计费服务"></a>3、计费服务</h4><p>服务名：计费服务<br>项目名：Ceilometer<br>功能    ：收集云平台资源使用数据，用来计费或者性能监控</p>
<h3 id="高层服务项目1个"><a href="#高层服务项目1个" class="headerlink" title="高层服务项目1个"></a>高层服务项目1个</h3><h4 id="1、编排服务"><a href="#1、编排服务" class="headerlink" title="1、编排服务"></a>1、编排服务</h4><p>服务名：编排服务<br>项目名：Heat<br>功能    ：自动化部署应用，自动化管理应用的整个生命周期。主要用于：PaaS</p>
<h1 id="4、openstack各组件到详解和运行流程"><a href="#4、openstack各组件到详解和运行流程" class="headerlink" title="4、openstack各组件到详解和运行流程"></a>4、openstack各组件到详解和运行流程</h1><h2 id="各组件的逻辑关系图："><a href="#各组件的逻辑关系图：" class="headerlink" title="各组件的逻辑关系图："></a>各组件的逻辑关系图：</h2><p><img src="http://note.youdao.com/yws/public/resource/436221f83d79dd07525663aac919173c/xmlnote/0D6CA74259FE4025977AFECF3CD31A55/5213" alt="image"></p>
<h2 id="openstack新建云主机到流程图："><a href="#openstack新建云主机到流程图：" class="headerlink" title="openstack新建云主机到流程图："></a>openstack新建云主机到流程图：</h2><p><img src="http://note.youdao.com/yws/public/resource/436221f83d79dd07525663aac919173c/xmlnote/3E0472F16EB346F8BB94708886876C9F/5214" alt="image"></p>
<h2 id="虚拟机的启动过程："><a href="#虚拟机的启动过程：" class="headerlink" title="虚拟机的启动过程："></a>虚拟机的启动过程：</h2><p>1、界面或命令行通过RESTful API向keystone获取认证信息（Horizon）<br>2、keystone通过用户请求的认证信息，并生成auth-token返回给对应的认证请求。<br>3、界面或命令行通过RESTful API向nova-api发送一个boot instance的请求（携带auth-token）<br>4、nova-api接受请求后，会向keystone发送请求认证信息，查看token是否为有效的用户和token<br>5、keystone验证token是否有效，如果有效则返回有效的认证和对应的角色<br>6、通过认证后，nova-api和数据库通讯<br>7、初始化新建的虚拟机数据库信息。<br>8、nova-api通过rpc.call向nova-scheduler请求是否有创建虚拟机的资源（Host ID）<br>9、nova-scheduler进程侦听消息队列，获取nova-api的请求<br>10、nova-scheduler通过查询nova数据库中计算资源的情况，并通过调度算法计算符合虚拟机创建需要的主机。<br>11、对于有符合虚拟机创建的主机，nova-scheduler更新数据库中虚拟机对应的物理主机信息。<br>12、nova-scheduler通过rpc.cast向nova-compute发送对应的创建虚拟机请求的消息<br>13、nova-compute会从对应的消息队列中获取创建虚拟机请求的消息。<br>14、nova-compute通过rpc.call向nova-conductor请求获取虚拟机消息。（Flavor）<br>15、nova-conductor从消息队列中拿到nova-compute请求消息。<br>16、nova-conductor根据消息查询虚拟机对应的信息。<br>17、nova-conductor从数据库中获得虚拟机对应信息<br>18、nova-conductor把虚拟机信息通过消息的方式发送到消息队列中。<br>19、nova-compute从对应的消息队列中获取虚拟机信息消息。<br>20、nova-compute通过keystone的RESTfull API拿到认证的token，并通过HTTP请求glance-api获取创建虚拟机所需要镜像。<br>21、glance-api向keystone认证token是否有效，并返回验证结果。<br>22、token验证通过，nova-compute获得虚拟机镜像信息(URL)。<br>23、nova-compute通过keystone的RESTfull API拿到认证k的token，并通过HTTP请求neutron-server获取创建虚拟机所需要的网络信息。<br>24、neutron-server向keystone认证token是否有效，并返回验证结果。<br>25、token验证通过，nova-compute获得虚拟机网络信息。<br>26、nova-compute通过keystone的RESTfull API拿到认证的token，并通过HTTP请求cinder-api获取创建虚拟机所需要的持久化存储信息。<br>27、cinder-api向keystone认证token是否有效，并返回验证结果。<br>28、token验证通过，nova-compute获得虚拟机持久化存储信息。<br>29、nova-compute根据instance的信息调用配置的虚拟化驱动来创建虚拟机。</p>
<h2 id="对复杂的模块进行展开："><a href="#对复杂的模块进行展开：" class="headerlink" title="对复杂的模块进行展开："></a>对复杂的模块进行展开：</h2><h3 id="1、Keystone"><a href="#1、Keystone" class="headerlink" title="1、Keystone"></a>1、Keystone</h3><p>User ：指使用Openstack service的用户，可以是人、服务、系统，但凡使用了Openstack service的对象都可以称为User</p>
<p>Project（Tenant）：可以理解为一个人、或服务所拥有的 资源集合 。在一个Project(Tenant)中可以包含多个User，每一个User都会根据权限的划分来使用Project(Tenant)中的资源。比如通过Nova创建虚拟机时要指定到某个Project中，在Cinder创建卷也要指定到某个Project中。User访问Project的资源前，必须要与该Project关联，并且指定User在Project下的Role。</p>
<p>Role：用于划分权限。可以通过给User指定Role，使User获得Role对应的操作权限。Keystone返回给User的Token包含了Role列表，被访问的Services会判断访问它的User和User提供的Token中所包含的Role。系统默认使用管理Role admin和成员Role <em>member</em> 。</p>
<p>Policy：OpenStack对User的验证除了OpenStack的身份验证以外，还需要鉴别User对某个Service是否有访问权限。Policy机制就是用来控制User对Project（Tenant）中资源(包括Services)的操作权限。对于Keystone service来说，Policy就是一个JSON文件，默认是/etc/keystone/policy.json。通过配置这个文件，Keystone Service实现了对User基于Role的权限管理。</p>
<p>Token ：是一个字符串表示，作为访问资源的令牌。Token包含了在 指定范围和有效时间内 可以被访问的资源。EG. 在Nova中一个tenant可以是一些虚拟机，在Swift和Glance中一个tenant可以是一些镜像存储，在Network中一个tenant可以是一些网络资源。Token一般被User持有。</p>
<p>Credentials：用于确认用户身份的凭证</p>
<p>Authentication：确定用户身份的过程</p>
<p>Service：Openstack service，即Openstack中运行的组件服务。</p>
<p>Endpoint：一个可以通过网络来访问和定位某个Openstack service的地址，通常是一个URL。比如，当Nova需要访问Glance服务去获取image 时，Nova通过访问Keystone拿到Glance的endpoint，然后通过访问该endpoint去获取Glance服务。我们可以通过Endpoint的region属性去定义多个region。Endpoint 根据使用对象分为三类：<br>  ● admin url –&gt; 给admin用户使用，Post：35357<br>  ● internal url –&gt; OpenStack内部服务使用来跟别的服务通信，Port：5000<br>  ● public url –&gt; 其它用户可以访问的地址，Post：5000<br>创建完service后创建API EndPoint. 在openstack中，每一个service都有三种Endpoints. Admin, public, internal。 Admin是用作管理用途的，如它能够修改user/tenant(project)。 public 是让客户调用的，比如可以部署在外网上让客户可以管理自己的云。internal是openstack内部调用的。三种Endpoints 在网络上开放的权限一般也不同。Admin通常只能对内网开放，public通常可以对外网开放internal通常只能对安装有openstack对服务的机器开放。</p>
<h3 id="2、nova和cinder"><a href="#2、nova和cinder" class="headerlink" title="2、nova和cinder"></a>2、nova和cinder</h3><p>nova主要组成：<br>  ● nova-api<br>  ● nova-scheduler<br>  ● nova-compute<br>  ● nova-conductor<br>cinder主要组成：<br>  ● cinder-api<br>  ● cinder-scheduler<br>  ● cinder-volume</p>
<p>cinder-api是cinder服务的Endpoint，提供rest接口，负责处理client请求。并将RPC请求发送给cinder-scheduler组件</p>
<p>cinder-scheduler负责cinder调度，其核心部分就是scheduler_drver，作为scheduler manager的driver，负责cinder-volume具体的调度处理，发送cinder RPC请求得到选择的cinder-volume</p>
<p>cinder-volume负责具体的volume请求处理，由不同的后端存储提供volume存储空间。</p>
<p>cinder架构图：<br><img src="http://note.youdao.com/yws/public/resource/436221f83d79dd07525663aac919173c/xmlnote/C8711C8B72F8412996A76416772F0E27/5215" alt="image"></p>
<h3 id="RPC介绍："><a href="#RPC介绍：" class="headerlink" title="RPC介绍："></a>RPC介绍：</h3><p>openstack组件的通信：调用各个组件的api提供的rest接口，<br>组件内的通信：基于RPC（远程过程调用）机制，而RPC机制是基于</p>
<p>从RPC使用的角度出发，nova、neutron，和cinder的流程是相似的，所以我们以cinder为列，阐述RPC机制：    </p>
<p>Openstack 组件内部的 RPC（Remote Producer Call）机制的实现是基于 AMQP(Advanced Message Queuing Protocol)作为通讯模型，从而满足组件内部的松耦合性。AMQP 是用于异步消息通讯的消息中间件协议，AMQP 模型有四个重要的角色:<br>1、Exchange：根据 Routing key 转发消息到对应的 Message Queue 中<br>2、 Routing key：用于 Exchange 判断哪些消息需要发送对应的 Message Queue<br>3、Publisher：消息发送者，将消息发送的 Exchange 并指明 Routing Key，以便 Message Queue可以正确的收到消息<br>4、Consumer：消息接受者，从 Message Queue 获取消息</p>
<p>消息发布者 Publisher 将 Message 发送给 Exchange 并且说明 Routing Key。Exchange 负责根据 Message 的 Routing Key 进行路由，将 Message 正确地转发给相应的 Message Queue。监听在 Message Queue 上的 Consumer 将会从 Queue 中读取消息。Routing Key 是 Exchange 转发信息的依据，因此每个消息都有一个 Routing Key 表明可以接受消息的目的地址，而每个 Message Queue 都可以通过将自己想要接收的 Routing Key 告诉 Exchange 进行 binding，这样 Exchange 就可以将消息正确地转发给相应的 Message Queue。</p>
<p>Publisher可以分为4类：</p>
<ol>
<li>Direct Publisher发送点对点的消息；</li>
<li>Topic Publisher采用“发布——订阅”模式发送消息；</li>
<li>Fanout Publisher发送广播消息的发送；</li>
<li>Notify Publisher同Topic Publisher，发送 Notification 相关的消息</li>
</ol>
<p>Exchange可以分为4类：</p>
<ol>
<li>Direct Exchange根据Routing Key进行精确匹配，只有对应的 Message Queue 会接受到消息；</li>
<li>Topic Exchange根据Routing Key进行模式匹配，只要符合模式匹配的Message Queue都会收到消息；</li>
<li>Fanout Exchange将消息转发给所有绑定的Message Queue。</li>
</ol>
<p>AMQP消息模型：</p>
<p>Client 端发送 RPC 请求由 publisher 发送消息并声明消息地址，consumer 接收消息并进行消息处理，如果需要消息应答则返回处理请求的结果消息。OpenStack RPC 模块提供了 rpc.call，rpc.cast, rpc.fanout_cast 三种 RPC 调用方法，发送和接收 RPC 请求。</p>
<h3 id="3、neutron"><a href="#3、neutron" class="headerlink" title="3、neutron"></a>3、neutron</h3><p>neutron包含组件：</p>
<ol>
<li>neutron-server</li>
<li>neutron-plugin</li>
<li>neutron-agent<br>各个组件的作用到介绍<br>1.Neutron-server可以理解为一个专门用来接收Neutron REST API调用的服务器，然后负责将不同的rest api分发到不同的neutron-plugin上。<br>2.Neutron-plugin可以理解为不同网络功能实现的入口，各个厂商可以开发自己的plugin。Neutron-plugin接收neutron-server分发过来的REST API，向neutron database完成一些信息的注册，然后将具体要执行的业务操作和参数通知给自身对应的neutron agent。<br>3.Neutron-agent可以直观地理解为neutron-plugin在设备上的代理，接收相应的neutron-plugin通知的业务操作和参数，并转换为具体的设备级操作，以指导设备的动作。当设备本地发生问题时，neutron-agent会将情况通知给neutron-plugin。<br>4.Neutron database，顾名思义就是Neutron的数据库，一些业务相关的参数都存在这里。<br>5.Network provider，即为实际执行功能的网络设备，一般为虚拟交换机（OVS或者Linux Bridge）。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> OpenStack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[7月10日面试题总结]]></title>
      <url>/2017/07/10/7%E6%9C%8810%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="c-的类型转换"><a href="#c-的类型转换" class="headerlink" title="c++的类型转换"></a>c++的类型转换</h1><ul>
<li>static_cast</li>
<li>const_cast</li>
<li>dynamic_cast</li>
<li>reinterpret_cast</li>
</ul>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>可以实现C++中内置基本数据类型之间的相互转换。如果涉及到类的话，static_cast只能在有相互联系的类型中进行相互转换。父类转换为子类或子类转换为父类。如果是没有任何关系的类之间转换，编译会出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int c = static_cast&lt;int&gt;(9.77);</span><br><span class="line"></span><br><span class="line">class A&#123;&#125;;</span><br><span class="line">class B :public A &#123;&#125;</span><br><span class="line">class C&#123;&#125;</span><br><span class="line"></span><br><span class="line">A * a = new A();</span><br><span class="line"></span><br><span class="line">B * b;</span><br><span class="line">C * c;</span><br><span class="line"></span><br><span class="line">b = static_cast&lt;B&gt;(a);   //正常执行</span><br><span class="line">c = static_cast&lt;C&gt;(a);   //编译出错，因为A和C之间无联系</span><br></pre></td></tr></table></figure>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>const_cast操作不能在不同的种类间转换。主要是用来去掉const属性，当然也可以加上const属性。主要是用前者，后者很少用。</p>
<p>去掉const属性：const_case<int*> (&amp;num)，常用，因为不能把一个const变量直接赋给一个非const变量，必须要转换。</int*></p>
<p>加上const属性：const int<em> k = const_case&lt;const int</em>&gt;(j)，一般很少用，因为可以把一个非const变量直接赋给一个const变量，比如：const int* k = j;</p>
<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>在某些情况下，为了适应接口类型要求，需要将int转化成uint,double转化成int64_t等，但是经过这种转化之后可能会有数据损失。如果只是为了适应接口，最终还是希望读出原始数据，那么可以选用reinterpret_cast</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;stdint.h&gt;  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">  int64_t i = 0;  </span><br><span class="line">  double d = 1.1;  </span><br><span class="line">  </span><br><span class="line">  int64_t j = reinterpret_cast&lt;int64_t&amp;&gt;(d);  </span><br><span class="line">  double j2 = reinterpret_cast&lt;double&amp;&gt;(j);  </span><br><span class="line">    </span><br><span class="line">  int64_t k = static_cast&lt;int64_t&gt;(d);  </span><br><span class="line">  double k2 = static_cast&lt;double&gt;(k);  </span><br><span class="line">  </span><br><span class="line">  printf(&quot;org=%lf, reintterpret forw(double=&gt;int64_t)=%ld\t,  reintterpret back(int64_t=&gt;double)=%lf\n&quot;, d, j, j2);  </span><br><span class="line">  printf(&quot;org=%lf, static forw(double=&gt;int64_t)=%ld\t, static back(int64_t=&gt;double)=%lf\n&quot;, d, k, k2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。<br>（2）不能用于内置的基本数据类型的强制转换。<br>（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。<br>（4）继承关系的类指针对象或引用之间转换和包含有虚函数之间对象指针的转换<br>（5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比               static_cast更安全。</p>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[7月6日面试题总结]]></title>
      <url>/2017/07/06/7%E6%9C%886%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="c-中的科学计数法"><a href="#c-中的科学计数法" class="headerlink" title="c++中的科学计数法"></a>c++中的科学计数法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.01 ==&gt; 1e-2</span><br><span class="line">100  ==&gt; 1e2</span><br></pre></td></tr></table></figure>
<h1 id="C-C-中逗号表达式的用法"><a href="#C-C-中逗号表达式的用法" class="headerlink" title="C/C++中逗号表达式的用法"></a>C/C++中逗号表达式的用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1 = (5,6); //必须要加括号否则编译出错</span><br></pre></td></tr></table></figure>
<p>如上代码所示，在c/c++中，t1等于逗号最后面的那个值，即：t1=5；</p>
<h1 id="有符号和有符号数相加"><a href="#有符号和有符号数相加" class="headerlink" title="有符号和有符号数相加"></a>有符号和有符号数相加</h1><p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	long long a = 0x7FFFFFFFFFFFFFFF;</span><br><span class="line">	unsigned long long b = 0x8000000000000000;</span><br><span class="line">	cout &lt;&lt; (a + b) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; typeid(a + b).name() &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从输出结果可知：</p>
<p>有符号+无符号 = 无符号</p>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络地址转换技术-NAT]]></title>
      <url>/2017/05/23/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%8A%80%E6%9C%AF-NAT/</url>
      <content type="html"><![CDATA[<h1 id="IPv4地址划分的方式"><a href="#IPv4地址划分的方式" class="headerlink" title="IPv4地址划分的方式"></a>IPv4地址划分的方式</h1><ul>
<li>标准分类的IP地址</li>
<li>划分子网的三级地址结构</li>
<li>构成超网的CIDR技术</li>
<li>网络地址转换技术<br>之前，我已经总结了：<a href="https://ouyanglianjun.github.io/2017/05/08/%E6%A0%87%E5%87%86IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">标准分类的IP地址</a>、<a href="https://ouyanglianjun.github.io/2017/05/10/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E7%9A%84%E4%B8%89%E7%BA%A7%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">划分子网的三级地址结构</a>和<a href="https://ouyanglianjun.github.io/2017/05/22/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1-CIDR/#more" target="_blank" rel="noopener">CIDR技术</a>，这篇博客我们继续介绍下一种地址划分的方式：网络地址转换技术</li>
</ul>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="公网IP地址"><a href="#公网IP地址" class="headerlink" title="公网IP地址"></a>公网IP地址</h2><p>也叫全局地址，是指合法的IP地址，它是由NIC（网络信息中心）或者ISP(网络服务提供商)分配的地址，对外代表一个或多个内部局部地址，是全球统一的可寻 址的地址。</p>
<h2 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h2><p>也叫专用IP地址，属于非注册地址，专门为组织机构内部使用。因特网分配编号委员会（IANA）保留了3块IP地址做为私有IP地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A类地址中的：</span><br><span class="line">10.0.0.0 ——— 10.255.255.255</span><br><span class="line">B类地址中的：</span><br><span class="line">172.16.0.0——— 172.16.255.255</span><br><span class="line">C类地址中的：</span><br><span class="line">192.168.0.0———192.168.255.255</span><br></pre></td></tr></table></figure>
<h1 id="NAT原理"><a href="#NAT原理" class="headerlink" title="NAT原理"></a>NAT原理</h1><p>简单地说，NAT就是在局域网内部网络中使用内部地址，而当内部节点要与外部网络进行通讯时，就在网关（可以理解为出口，打个比方就像院子的门一样）处，将内部地址替换成公用地址，从而在外部公网（internet）上正常使用，NAT可以使多台计算机共享Internet连接，这一功能很好地解决了公共 IP地址紧缺的问题。通过这种方法，可以只申请一个合法IP地址，就把整个局域网中的计算机接入Internet中。这时，NAT屏蔽了内部网络，所有内部网计算机对于公共网络来说是不可见的，而内部网计算机用户通常不会意识到NAT的存在。如下图所示，展示了一个NAT的工作原理：<br><img src="http://i4.buimg.com/593129/622f326785ae409e.jpg" alt="image"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>NAT的提出主要是因为当前IPv4地址短缺，而IPv6还没有普及，所以需要使用NAT来解决当前Ip地址短缺的危机。</p>
]]></content>
      
        
        <tags>
            
            <tag> IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[无类别域间路由-CIDR]]></title>
      <url>/2017/05/22/%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1-CIDR/</url>
      <content type="html"><![CDATA[<h1 id="IPv4地址划分的方式"><a href="#IPv4地址划分的方式" class="headerlink" title="IPv4地址划分的方式"></a>IPv4地址划分的方式</h1><ul>
<li>标准分类的IP地址</li>
<li>划分子网的三级地址结构</li>
<li>构成超网的CIDR技术</li>
<li>网络地址转换技术<br>之前，我已经总结了：<a href="https://ouyanglianjun.github.io/2017/05/08/%E6%A0%87%E5%87%86IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">标准分类的IP地址</a>和<a href="https://ouyanglianjun.github.io/2017/05/10/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E7%9A%84%E4%B8%89%E7%BA%A7%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">划分子网的三级地址结构</a>，这篇博客我们继续介绍下一种地址划分的方式：构成超网的CIDR技术</li>
</ul>
<h1 id="CIDR技术的提出历程（参考资料：CIDR介绍）"><a href="#CIDR技术的提出历程（参考资料：CIDR介绍）" class="headerlink" title="CIDR技术的提出历程（参考资料：CIDR介绍）"></a>CIDR技术的提出历程（参考资料：<a href="https://wenku.baidu.com/view/e3e24a242e3f5727a4e96239.html" target="_blank" rel="noopener">CIDR介绍</a>）</h1><ul>
<li>B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！</li>
<li>因特网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）</li>
<li>整个 IPv4 的地址空间最终将全部耗尽</li>
<li>1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩 码。使用变长子网掩码 VLSM (Variable Length Subnet Mask)可进一步提高 IP 地址资源的利用率</li>
<li>在 VLSM 的基础上又进一步研究出无分类编址方法，它的正式名字是无分类域间路 由选择 CIDR (Classless Inter-Domain Routing)。</li>
</ul>
<h1 id="CIDR主要特点"><a href="#CIDR主要特点" class="headerlink" title="CIDR主要特点"></a>CIDR主要特点</h1><ul>
<li>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有 效地分配 IPv4 的地址空间</li>
<li>CIDR使用各种长度的“网络前缀” (network-prefix)来代替分类地址中的网络号和子网 号</li>
<li>IP 地址从三级编址（使用子网掩码）又回到了两级编址</li>
</ul>
<h1 id="无分类的两级编址"><a href="#无分类的两级编址" class="headerlink" title="无分类的两级编址"></a>无分类的两级编址</h1><ul>
<li>无分类的两级编址的记法是：  IP地址= {&lt;网络前缀&gt;, &lt;主机号&gt;}</li>
<li>CIDR 还使用“斜线记法”(slash notation)，它又称为CIDR记法，即在 IP 地址后面加上 一个斜线“/”，然后写上网络前缀所占的比特数，如：100.100.100.0/24</li>
<li>CIDR 将网络前缀都相同的连续的 IP 地址组成“CIDR 地址块</li>
</ul>
<h1 id="CIDR地址块"><a href="#CIDR地址块" class="headerlink" title="CIDR地址块"></a>CIDR地址块</h1><ul>
<li>128.14.32.0/20 表示的地址块共有 2^12(4096) 个地址（因为斜线后面的 20 是网络前缀的比 特数，所以主机号的比特数是 12）</li>
<li>这个地址块的起始地址是 128.14.32.0</li>
<li>128.14.32.0/20 地址块的最小地址：128.14.32.0</li>
<li>128.14.32.0/20 地址块的最大地址：128.14.32.255</li>
<li>全 0 和全 1 的主机号地址用作特殊用途.全0为本网络地址，全1是广播地址</li>
</ul>
<h1 id="󰂄路由聚合-route-aggregation"><a href="#󰂄路由聚合-route-aggregation" class="headerlink" title="󰂄路由聚合(route aggregation)"></a>󰂄路由聚合(route aggregation)</h1><ul>
<li>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由 表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由</li>
<li>路由聚合也称为构成超网</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>网络122.21.136.0/24和122.21.143.0/24经过路由汇聚，得到的网络地址是： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把题干中的2个网络地址都转换成二进制： </span><br><span class="line">01111010. 00010101. 10001000. 00000000  </span><br><span class="line">01111010. 00010101. 10001111. 00000000  他们的前21位是一样的，所以经过路由汇聚后得到的网络地址是：</span><br><span class="line">01111010. 00010101.10001000. 00000000/21</span><br><span class="line">也就是：</span><br><span class="line">122.21.136.0/21</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[5月11日笔试题总结]]></title>
      <url>/2017/05/11/5%E6%9C%8811%E6%97%A5%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式就是指一个类只有一个实例，该实例是被所有的程序模块共享。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>GUI中只有一个鼠标对象，操作系统只有一个窗口管理器等</p>
<h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//单例模式</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">  A()             //创建一个私有的构造函数</span><br><span class="line">  &#123;</span><br><span class="line">      cout&lt;&lt;&quot;A&quot;&lt;&lt;endl;    //只被输出一次</span><br><span class="line">  &#125;</span><br><span class="line">  static A *a;    //唯一的类对象</span><br><span class="line">public:</span><br><span class="line">  static A * get()&#123;</span><br><span class="line">       if(a==NULL)&#123;   //判断是否第一次调用 </span><br><span class="line">          a=new A();</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">     A * p1=A::get();</span><br><span class="line">     A *p2=p1-&gt;get();</span><br><span class="line">     system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>
<p>更多的单例模式的知识可以参考博客：<a href="http://blog.csdn.net/hackbuteer1/article/details/7460019" target="_blank" rel="noopener">c++单例模式</a></p>
<h1 id="c语言用：非零整数表示逻辑真，0表示逻辑假"><a href="#c语言用：非零整数表示逻辑真，0表示逻辑假" class="headerlink" title="c语言用：非零整数表示逻辑真，0表示逻辑假"></a>c语言用：非零整数表示逻辑真，0表示逻辑假</h1><p>C语言没有BOOL类型变量。boolean类型是C++所独有的，其别名有bool 和 BOOL，都可以定义布尔变量。</p>
<h1 id="函数重载的识别的标准"><a href="#函数重载的识别的标准" class="headerlink" title="函数重载的识别的标准"></a>函数重载的识别的标准</h1><ul>
<li>函数名相同</li>
<li>在类继承中，一个父类的方法要在子类中重载，该方法必须要对子类是可见的</li>
<li>函数的参数个数不同、类型不同<br>只要满足上述的几点，该函数就是重载函数。<strong>重载函数和返回类型是无关的。但是不能出现只是返回值不同的重载函数，否则会编译出错。</strong>错误代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f(int a)&#123;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float f(int a)&#123;</span><br><span class="line">    </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	f(10);</span><br><span class="line">	f(10);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码执行，会编译出错</p>
<h1 id="STL中的unordered-map和priority-queue使用的底层数据结构分别hashtable和heap"><a href="#STL中的unordered-map和priority-queue使用的底层数据结构分别hashtable和heap" class="headerlink" title="STL中的unordered_map和priority_queue使用的底层数据结构分别hashtable和heap"></a>STL中的unordered_map和priority_queue使用的底层数据结构分别hashtable和heap</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单例模式是使用最多的设计模式，对于单例模式最基本要掌握它的含义和一个简单的实现例子。对于函数重载，需要知道函数重载的原理和其基本的判断方式。并且我们还需要同时掌握函数重写的含义和用途。</p>
<p>具体的扩展资料：</p>
<ul>
<li><a href="http://blog.csdn.net/candcplusplus/article/details/12746975" target="_blank" rel="noopener">函数重载实现原理</a></li>
<li><a href="http://blog.csdn.net/alpha_love/article/details/61922093" target="_blank" rel="noopener">函数重写、重载、重定义</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[5月10号笔试题总结]]></title>
      <url>/2017/05/10/5%E6%9C%8810%E5%8F%B7%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><h2 id="什么是内联函数"><a href="#什么是内联函数" class="headerlink" title="什么是内联函数"></a>什么是内联函数</h2><p>内联函数就是程序在编译的时候，将程序中出现的内联函数的调用用具体的函数体替换。这么做的目的就是为提高程序效率</p>
<h2 id="内联函数和宏的区别"><a href="#内联函数和宏的区别" class="headerlink" title="内联函数和宏的区别"></a>内联函数和宏的区别</h2><ul>
<li>内联函数在运行时可调试，而宏定义不可以;</li>
<li>编译器会对<strong>内联函数的参数类型做安全检查或自动类型转换（同普通函数）</strong>，而宏定义则不会； </li>
<li>内联函数可以访问类的成员变量，宏定义则不能； </li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数。</li>
</ul>
<p>内联函数的扩展可以参考博客：<a href="http://blog.csdn.net/coder_xia/article/details/6723387" target="_blank" rel="noopener">c++内联函数的介绍</a></p>
<h1 id="结构中声明变量使用“：”的含义"><a href="#结构中声明变量使用“：”的含义" class="headerlink" title="结构中声明变量使用“：”的含义"></a>结构中声明变量使用“：”的含义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct mybitfields</span><br><span class="line">&#123;</span><br><span class="line">    unsigned short a : 4;</span><br><span class="line">    unsigned short b : 5;</span><br><span class="line">    unsigned short c : 7;</span><br><span class="line">&#125; test</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    test.a = 2;</span><br><span class="line">    test.b = 3;</span><br><span class="line">    test.c = 0;</span><br><span class="line"> </span><br><span class="line">    i = *((short *)&amp;test);</span><br><span class="line">    printf(&quot;%d\n&quot;, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构中，变量后面的冒号是指的是该变量所占用的位数。所以我们可以知道该结构体中，a占了4位，b占了5位，c占了7位，恰好为2个字节，下面是简单的示意图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量名  位数</span><br><span class="line">test    15 14 13 12 11 10 9 |8 7 6 5 4 |3 2 1 0</span><br><span class="line">test.a                      |          |0 0 1 0</span><br><span class="line">test.b                      |0 0 0 1 1 |</span><br><span class="line">test.c   0  0  0  0  0  0 0 |          |</span><br></pre></td></tr></table></figure></p>
<p>所以，通过&amp;test取得两个字节的地址的内容，存放在i中的二进制的值为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0  0  0  0  0  0 0 0 0 0 1 1 0 0 1 0=50</span><br></pre></td></tr></table></figure>
<h1 id="派生类对象中，可以访问基类中的："><a href="#派生类对象中，可以访问基类中的：" class="headerlink" title="派生类对象中，可以访问基类中的："></a>派生类<strong>对象</strong>中，可以访问基类中的：</h1><ul>
<li>公有继承的公有成员</li>
<li>公有继承的保护成员只能在派生类中访问</li>
</ul>
<p>有关类继承的博客可以参考博客：<a href="http://blog.csdn.net/qq_35644234/article/details/52825311" target="_blank" rel="noopener">c++的继承总结</a></p>
<h1 id="使用位运算实现两个数的交换"><a href="#使用位运算实现两个数的交换" class="headerlink" title="使用位运算实现两个数的交换"></a>使用位运算实现两个数的交换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=a^b;</span><br><span class="line">b=b^a;</span><br><span class="line">a=a^b;</span><br></pre></td></tr></table></figure>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 ^ 1 == 0;</span><br><span class="line">1 ^ 0 == 1;</span><br><span class="line">0 ^ 1 == 1;</span><br><span class="line">0 ^ 0 == 0;</span><br></pre></td></tr></table></figure>
<p>通过上图，我们可以知道，只要是和0异或就是保留原来的值，和1异或就是将原来的值取反。则通过异或进行值交换的整个流程是：</p>
<ul>
<li>第一次异或是把两个数的二进制数中的相同的部分和不同部分区分开来，相同的则就是设置为0，代表不用修改的。不同的部分就设置为1,代表待会需要修改的部分</li>
<li>第二次异或是通过与b异或后，就可以得到a的原来的值</li>
<li>第三次异或是通过与原来a的值异或后，就可以得到原来b的值<br>通过上述三个步骤，就可以完成两个数的交换。</li>
</ul>
<h2 id="其他扩展"><a href="#其他扩展" class="headerlink" title="其他扩展"></a>其他扩展</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=a+b;</span><br><span class="line">b=a-b;</span><br><span class="line">a=a-b;</span><br></pre></td></tr></table></figure>
<p>上述，同样是完成两个数交换的一种方法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>c++内联函数是一种很好的替换宏函数的一种机制，如果是宏常量就需要使用const去替换。位运算是一个高效简单的东西，以后想问题的时候可以多往这个方向考虑</p>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[划分子网的三级地址结构]]></title>
      <url>/2017/05/10/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E7%9A%84%E4%B8%89%E7%BA%A7%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="IPv4地址划分的方式"><a href="#IPv4地址划分的方式" class="headerlink" title="IPv4地址划分的方式"></a>IPv4地址划分的方式</h1><ul>
<li>标准分类的IP地址</li>
<li>划分子网的三级地址结构</li>
<li>构成超网的CIDR技术</li>
<li>网络地址转换技术</li>
</ul>
<p>在上篇博客，我已经总结了：<a href="https://ouyanglianjun.github.io/2017/05/08/%E6%A0%87%E5%87%86IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">标准分类的IP地址</a>，这篇博客我们继续介绍下一种地址划分的方式：划分子网的三级地址结构</p>
<h1 id="什么是子网"><a href="#什么是子网" class="headerlink" title="什么是子网"></a>什么是子网</h1><p>子网的基本思想就是：将一个网络号下网络再次划分为多个网络段，而这些网络段的划分由该组织自行决定。子网的结构是：网络号-子网号-主机号。</p>
<h1 id="为什么要引入子网概念"><a href="#为什么要引入子网概念" class="headerlink" title="为什么要引入子网概念"></a>为什么要引入子网概念</h1><ul>
<li>提高了IP地址的使用效率。在标准分类的IP地址中，当我们把一个网络号分配给一个组织后，如果该组织给它的内部的主机都分配了IP地址后，还剩余很多闲置的IP地址时，其他组织无法合法利用该资源。但是子网的引入，可以大幅度的解决这个问题</li>
<li>提高了路由器的工作效率。IP数据包从网际上的一个网络到达另一个网络时，选择路径可以基于网络而不是主机。在大型的网际中，这一点优势特别明显，因为路由表中只存储网络信息而不是主机信息，这样可以大大简化路由表。</li>
</ul>
<h1 id="子网地址的结构与划分方法"><a href="#子网地址的结构与划分方法" class="headerlink" title="子网地址的结构与划分方法"></a>子网地址的结构与划分方法</h1><ul>
<li>子网号是从主机号中提取前几个位作为“子网号”，剩余的位数继续作为“主机号”，因此子网会形成：网络号-子网号-主机号</li>
<li>子网划分可以应用到A、B、C三类IP地址中。同一子网中的子网号相同。</li>
<li>子网的具体划分是组织自己内部的事情</li>
</ul>
<h1 id="如何识别出一个IP地址的网络号、子网号、主机号"><a href="#如何识别出一个IP地址的网络号、子网号、主机号" class="headerlink" title="如何识别出一个IP地址的网络号、子网号、主机号"></a>如何识别出一个IP地址的网络号、子网号、主机号</h1><p>首先，我们知道子网是应用于A、B、C三类IP地址的，所以通过IP地址的前三位就可以知道该IP地址的属于哪类IP地址，并且可以知道其网络号所占的位数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A类：0__   网络号：8位</span><br><span class="line">B类：10_   网络号：16位</span><br><span class="line">C类：11_   网络号：24位</span><br></pre></td></tr></table></figure>
<p>那么我们该如何从IP地址中提取出该IP地址的子网号了？这个时候，就需要引入<strong>子网掩码</strong>的概念。</p>
<h2 id="子网掩码作用"><a href="#子网掩码作用" class="headerlink" title="子网掩码作用"></a>子网掩码作用</h2><p>将IP地址划分为网络位和主机位。网络位包括了：网络号和子网号，所以可以通过子网掩码判断出IP地址的子网号。另外，A、B、C类地址都可以引入他它们自己的子网掩码，具体表现形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A类：255.0.0.0     前8位都是1</span><br><span class="line">B类：255.255.0.0   前16位都是1</span><br><span class="line">C类：255.255.255.0 前24位都是1</span><br></pre></td></tr></table></figure>
<h2 id="如何表示子网掩码"><a href="#如何表示子网掩码" class="headerlink" title="如何表示子网掩码"></a>如何表示子网掩码</h2><p>子网掩码和IP地址一样，都是4个字节的，左边是网络位，用二进制数字“1”表示；右边是主机位，用二进制数字“0”表示。</p>
<p>例如如果一个标准的B类地址，它本来有16位的主机号，现在选择前6位作为子网号，则一个B类地址就可以划分为：64个子网，该子网的掩码可以表示为如下两种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">255.255.252.0   表示前22位都是1.</span><br><span class="line">/22</span><br></pre></td></tr></table></figure>
<p>例如网络段:192.168.1.1/24的子网可以表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">255.255.255.0</span><br><span class="line">或</span><br><span class="line">/24</span><br></pre></td></tr></table></figure>
<h1 id="如何帮助一个组织划分子网"><a href="#如何帮助一个组织划分子网" class="headerlink" title="如何帮助一个组织划分子网"></a>如何帮助一个组织划分子网</h1><p>例如一个组织需要对一个B类地址：156.26.0.0进行划分，其中该组织的子网数数需要100个。</p>
<ul>
<li>考虑到该组织需要100个子网，所以需要的子网号位数为：7位（2^7&gt;100）。</li>
<li>子网的掩码为：255.255.254.0/23</li>
<li>每个子网可以分配的主机数量为：2^9-2。其中减去的两个分别为主机号全0和全1，全0为子网掩码用于标识一个网络段，全1为该子网内的广播地址。</li>
</ul>
<h1 id="如何通过子网掩码确定主机号、子网号、两个IP地址是否属于同一子网"><a href="#如何通过子网掩码确定主机号、子网号、两个IP地址是否属于同一子网" class="headerlink" title="如何通过子网掩码确定主机号、子网号、两个IP地址是否属于同一子网"></a>如何通过子网掩码确定主机号、子网号、两个IP地址是否属于同一子网</h1><ul>
<li>每个子网只有一个掩码，但需要注意，并不是子网掩码相同就是同一子网</li>
<li>子网号 = IP &amp; 子网掩码</li>
<li>主机号 = IP &amp; 掩码取反</li>
<li>如果子网号相同就是属于同一子网</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>假设一个网络中的主机为450台，那么分配一个C类地址不够用，分配一个B类地址又显得太浪费，在这种情况下，就提出了子网化的概念，子网的定义就是把主机地址中的一部分主机位借用为网络位。从而可以让一个B类地址被多个组织使用。这也正是子网的奇妙之处。</p>
]]></content>
      
        
        <tags>
            
            <tag> IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[标准分类的IP地址]]></title>
      <url>/2017/05/08/%E6%A0%87%E5%87%86IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h1 id="什么是IP地址"><a href="#什么是IP地址" class="headerlink" title="什么是IP地址"></a>什么是IP地址</h1><p>IP地址是网络层的地址，主要是用于路由器的寻找。每个IP地址可以唯一、确定地识别台主机、路由器或网络接口。另外，路由器主要功能是转发IP数据报和路由选择，我们将在后续博客介绍路由器的详细知识，正是因为它要执行IP协议，所以需要为它分配一个IP地址。</p>
<h1 id="如何划分IP地址了？"><a href="#如何划分IP地址了？" class="headerlink" title="如何划分IP地址了？"></a>如何划分IP地址了？</h1><p>我这里介绍的都是IPv4地址划分的方法：</p>
<ul>
<li>标准分类的IP地址</li>
<li>划分子网的三级地址结构</li>
<li>构成超网的CIDR技术</li>
<li>网络地址转换技术<br>而本文就是要介绍最开始的IPv4的地址划分的方式：标准分类的IP地址，而其他三种也将在后续的博客中介绍。</li>
</ul>
<h1 id="IPv4地址的介绍"><a href="#IPv4地址的介绍" class="headerlink" title="IPv4地址的介绍"></a>IPv4地址的介绍</h1><p>IPv4的地址的长度为：32比特字，它通常是通过点分十进制记法书写，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.1</span><br></pre></td></tr></table></figure>
<p>另外，IPv4地址由网络号和主机号组成。</p>
<h1 id="标准分类的IP地址"><a href="#标准分类的IP地址" class="headerlink" title="标准分类的IP地址"></a>标准分类的IP地址</h1><p>标准分类的IP地址就是根据网络号的长度，把IPv4地址分为了5类，如下图所示：<br><img src="http://img0.ph.126.net/RkwIn5JoY-9l_6tURNRGRw==/6631929782818300044.jpg" alt="image"></p>
<h2 id="A类地址："><a href="#A类地址：" class="headerlink" title="A类地址："></a>A类地址：</h2><p>网络号占了：8位。第一位一定是：0，剩下的7位可以自由分配。根据网络号可以把A类地址分为长度相等的128块IP地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0~0.255.255.255（网络号0）</span><br><span class="line">127.0.0.0~127.255.255.255（网络号127）</span><br><span class="line">10.0.0.0~10.255.255.255（网络号10）</span><br></pre></td></tr></table></figure></p>
<p>上述的三块A类地址，前两块有特殊用途，最后一块用于专用的地址。所以A类地址只可以分配给125个机构。每个机构又可以自行的分配他们的主机号，每个机构可以分配的主机个数为：2^24-2个，其中主机号全0和全1有特殊用途。A类IP地址的范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0~127.255.255.255（占整个IP地址的50%的地址）</span><br></pre></td></tr></table></figure>
<h2 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h2><p>网络号占了：16位，其中前两位一定是10，剩下的14位可以自行分配。对于16位的主机号，除了主机号全0和主机号全1用作特殊目的，一个B类IP地址允许分配的主机号为：2^16-2个。B类IP地址的范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">128.0.0.0~191.255.255.255</span><br></pre></td></tr></table></figure>
<h2 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h2><p>网络号占了：24位，其中前三位一定是：110，剩下的21位可以自行分配。对于8位的主机号，除了主机号全为1和全为0用于特殊用途，其他的：2^8-2个主机号都可以自行分配。C类IP地址的范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.0.0.0~223.255.255.255</span><br></pre></td></tr></table></figure>
<h2 id="D类地址"><a href="#D类地址" class="headerlink" title="D类地址"></a>D类地址</h2><p>D类IP地址不用于标识网络，用于其他特殊的用途，其前四位一定是：1110。D类IP地址的范围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">224.0.0.0~239.255.255.255</span><br></pre></td></tr></table></figure>
<h2 id="E类地址"><a href="#E类地址" class="headerlink" title="E类地址"></a>E类地址</h2><p>E类地址暂时保留，其前五位一定是：11110，地址覆盖范围为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">240.0.0.0~247.255.255.255</span><br></pre></td></tr></table></figure>
<h1 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h1><ul>
<li>网络号+主机号全0：代表指定的一个网络（其实它就是一个子网掩码，所以不可以使用）</li>
<li>网络号+主机号全1：对网络号上的所有主机进行广播（直接广播地址）</li>
<li>255.255.255.255：为受限广播地址，它将一个分组以广播的方式发给本物理网络中的所有主机。</li>
<li>0.0.0.0：网络上的本主机</li>
<li>127.0.0.1：回送地址，用于网络软件测试和本地进程间通信。</li>
</ul>
<h1 id="专用IP地址"><a href="#专用IP地址" class="headerlink" title="专用IP地址"></a>专用IP地址</h1><p><img src="http://img2.ph.126.net/s_qBhqITQp8jAat-w2y0HQ==/6632590589303925143.png" alt="image"><br>专用IP地址是在局域网内部使用的IP地址。如果使用私有地址的主机需要访问该局域网外部的服务器或主机，需要将私有地址转换为公有地址，转换的方式为：NAT。比如深圳大学就是一个大的局域网，它内部的主机使用的IP地址就是专用IP。</p>
<h1 id="标准分类的IP地址的问题"><a href="#标准分类的IP地址的问题" class="headerlink" title="标准分类的IP地址的问题"></a>标准分类的IP地址的问题</h1><ul>
<li>IP地址的有效利用率低</li>
<li>路由器的工作效率不高</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在TCP/IP协议族中，IP协议占着重中之重地位，而IP协议入门的第一个知识就是IP地址的划分，后续将继续介绍剩下的三种划分技术。IP协议中还有一个很重要的部分就是–路由器。</p>
]]></content>
      
        
        <tags>
            
            <tag> IP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[5月8号笔试题总结]]></title>
      <url>/2017/05/08/5%E6%9C%888%E5%8F%B7%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="STL中的一级容器"><a href="#STL中的一级容器" class="headerlink" title="STL中的一级容器"></a>STL中的一级容器</h2><p>vector 、 queue 、list</p>
<h2 id="数组做为参数会被退化为指针"><a href="#数组做为参数会被退化为指针" class="headerlink" title="数组做为参数会被退化为指针"></a>数组做为参数会被退化为指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void fun(char a[2])&#123;</span><br><span class="line">    int size=sizeof(a);    //4</span><br><span class="line">    int length=strlen(a);   //5</span><br><span class="line">&#125;</span><br><span class="line">char a[]=&quot;Hello&quot;;</span><br><span class="line">fun(a);</span><br></pre></td></tr></table></figure>
<p>如上程序，在c++和c中，函数形参是一个数组时，当其接受到一个数组作为实参时，那么形参数组就会退化为一个指针。所以sizeof的值会为4，因为参数已经退化为一个指针了，所以2也就不起作用了，所以strlen的值为5。</p>
<p>但是在c++中，引入了引用的概念，所以如果在c++中可以传递数组的引用，保护数组不退化为指针，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fun(char (&amp;a)[6])&#123; //这里的参数必须是等于传递进来的参数的长度，不然会编译出错</span><br><span class="line">	 cout&lt;&lt;sizeof(a)&lt;&lt;endl;   //6</span><br><span class="line">	 cout&lt;&lt;strlen(a)&lt;&lt;endl;   //5</span><br><span class="line">&#125;</span><br><span class="line">	char a[]=&quot;Hello&quot;;</span><br><span class="line">	fun(a);</span><br></pre></td></tr></table></figure></p>
<p>另外，在这里在总结一个知识点：sizeof是计算变量的内存的大小，所以需要把字符串最后的那个‘\0’算进来，而strlen是一个函数，就不需要加入最后的那个‘\0’.</p>
<h1 id="不同的编译器下，各种数据类型所占的字节数，主要是指针类型和long系列的类型"><a href="#不同的编译器下，各种数据类型所占的字节数，主要是指针类型和long系列的类型" class="headerlink" title="不同的编译器下，各种数据类型所占的字节数，主要是指针类型和long系列的类型"></a>不同的编译器下，各种数据类型所占的字节数，主要是指针类型和long系列的类型</h1><h2 id="32位处理器："><a href="#32位处理器：" class="headerlink" title="32位处理器："></a>32位处理器：</h2><ul>
<li>char ：1个字节</li>
<li>char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器</li>
<li>short int : 2个字节</li>
<li>int ：4字节</li>
<li>unsigned int：4字节</li>
<li>double：8字节</li>
<li>float：4字节</li>
<li>long: 4个字节</li>
<li>unsigned long：4字节</li>
<li>long long ：8字节</li>
</ul>
<h2 id="64位处理器："><a href="#64位处理器：" class="headerlink" title="64位处理器："></a>64位处理器：</h2><p>在64位下，主要有改变的有如下几个数据类型：</p>
<ul>
<li>char*(即指针变量): 8个字节</li>
<li>long: 8个字节</li>
<li>unsigned long: 8个字节</li>
</ul>
<p>另外，需要注意的是，任意的处理器都是按照4字节编址的，所以需要我们进行字节对齐。具体的对齐方式可以看下面的介绍：</p>
<ul>
<li>数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。</li>
<li>指定对齐值：#pragma pack (value)时的指定对齐值value。</li>
</ul>
<h1 id="位运算符的使用：使用位运算计算x-8的值："><a href="#位运算符的使用：使用位运算计算x-8的值：" class="headerlink" title="位运算符的使用：使用位运算计算x%8的值："></a>位运算符的使用：使用位运算计算x%8的值：</h1><p>答案是：x&amp;7，通过分析我们可以知道x%8是等于：x-(x&gt;&gt;3)，从中我可以知道x%8就是保留了x的二进制形式的最后三位，所以可以直接通过：x&amp;7实现x%8。</p>
]]></content>
      
        
        <tags>
            
            <tag> c++面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UDP的详细介绍]]></title>
      <url>/2017/05/08/UDP%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="UDP的概述"><a href="#UDP的概述" class="headerlink" title="UDP的概述"></a>UDP的概述</h1><p>UDP是一种无连接、不可靠、简单高效的面向报文传输的传输层协议。另外<strong>，使用UDP传输也是可以实现数据的可靠传输的，只是这些额外的功能需要应用程序自身实现。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP是面向连接、面向字节流、支持双工、支持并发连接、提供确认重传和拥塞控制的可靠的传输层协议</span><br></pre></td></tr></table></figure>
<h1 id="UDP的数据报格式"><a href="#UDP的数据报格式" class="headerlink" title="UDP的数据报格式"></a>UDP的数据报格式</h1><p><img src="http://i1.piimg.com/593129/cd911749e1e185be.jpg" alt="image"></p>
<ul>
<li>UDP的长度：它指的是整个UDP报文的长度。16位UDP的长度字段可以表示最大的值为：65535字节，而我们UDP的最小的报文长度就是：8字节，此时UDP报文中没有数据。</li>
<li>UDP校验和：这个UDP校验和和TCP的校验和一样，都是用于验证当前的数据报是否有损坏。而且它们的校验和值的初始化和使用方法都是一样的，都是要加入临时的伪报头。具体可以参考博客：<a href="https://ouyanglianjun.github.io/2017/05/05/TCP%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%A2%E5%A4%B1%E5%8E%9F%E5%9B%A0%EF%BC%88%E4%BB%8B%E7%BB%8D%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%9A%84%E8%AE%A1%E7%AE%97%EF%BC%89/" target="_blank" rel="noopener">检验和计算方式</a></li>
</ul>
<h1 id="UDP的优势"><a href="#UDP的优势" class="headerlink" title="UDP的优势"></a>UDP的优势</h1><ul>
<li>网络环境越来越稳定、可靠，给了UDP取代TCP的机会；此时TCP的拥塞处理、超时重传等机制显得有些多余。</li>
<li>UDP相比了TCP，传输速度快，更能满足实时性的要求。若是数据量大，TCP会有拥塞控制；若是丢包，还得等待重传；会有较大延时。</li>
<li>如果对数据有可靠传输的需求，应用可以通过一些机制来保证。 a. 发送方对所发的报文要求应答。 b. 报文头里加序号字段，交互时需检测（每次交互加1）</li>
<li>UDP分组首部开销小，可以提高数据的传输效率</li>
<li>UDP还支持一对一、一对多与多对多的交互式通信方式，所以多播和广播是需要通过UDP来实现的</li>
</ul>
<h1 id="UDP协议一次应该传输的数据的大小，如何确定？（参考博客：UDP一次应该传输多大的数据）"><a href="#UDP协议一次应该传输的数据的大小，如何确定？（参考博客：UDP一次应该传输多大的数据）" class="headerlink" title="UDP协议一次应该传输的数据的大小，如何确定？（参考博客：UDP一次应该传输多大的数据）"></a>UDP协议一次应该传输的数据的大小，如何确定？（参考博客：<a href="http://blog.163.com/yuyi_vc/blog/static/170371753201152901727665/" target="_blank" rel="noopener">UDP一次应该传输多大的数据</a>）</h1><p>以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).我们在后续介绍IP协议的时候，将会了解到如果整个IP数据报的长度大于MTU时候，将会被分片后再进行传输，而分片传输会大大的影响数据的传输速度。所以我们可以知道一个IP数据报的最大长度为：1500字节，其中IP数据报自身的首部长度为：20字节，然后，再加上UDP自身的首部长度：8字节，所以一次可以传输的数据最大为：1472字节。为避免被分片处理，最好把UDP的数据长度控制在：1472字节以内</p>
<p><strong>鉴于Internet上的标准MTU值为576字节,所以我建议在进行Internet的UDP编程时.最好将UDP的数据长度控制在548字节(576-8-20)以内.</strong></p>
<h1 id="UDP和TCP各自使用情况总结图"><a href="#UDP和TCP各自使用情况总结图" class="headerlink" title="UDP和TCP各自使用情况总结图"></a>UDP和TCP各自使用情况总结图</h1><p><img src="http://i2.muimg.com/593129/811db6065637e20f.jpg" alt="image"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过最后一点对TCP和UDP使用情况的总结，我们在实际的编程中，应当合理的选择传输层协议。</p>
]]></content>
      
        
        <tags>
            
            <tag> UDP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP拥塞控制]]></title>
      <url>/2017/05/07/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="什么是拥塞控制"><a href="#什么是拥塞控制" class="headerlink" title="什么是拥塞控制"></a>什么是拥塞控制</h1><p>所谓的拥塞控制就是防止有过多的报文进入网络而造成路由器与链路过载的情况发生。它不同于流量控制，流量控制只是简单的通过接收端的接收缓存来设置接收窗口值，从而控制发送方的发送速率，而拥塞控制则是考虑整个网络传输的情况，通过动态改变TCP的拥塞窗口的值，从而动态调整发送方的传输速率。</p>
<h1 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h1><p>拥塞窗口（cwnd）是发送方根据网络拥塞情况而得出的窗口值。而发送方的发送窗口的大小选择公式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送窗口=MIN（cwnd，rwnd）；其中rwnd为接收窗口，cwnd为拥塞窗口</span><br></pre></td></tr></table></figure></p>
<h1 id="如何判断网络中出现了拥塞了？"><a href="#如何判断网络中出现了拥塞了？" class="headerlink" title="如何判断网络中出现了拥塞了？"></a>如何判断网络中出现了拥塞了？</h1><p>只要网络中出现了“丢包事件”，发送方就认为在发送方到接收方的路径上的网络传输出现了拥塞。所谓的“丢包事件”，我们定义为：要么出现了超时，报么收到了3个冗余的ACK报文。</p>
<h1 id="如何进行拥塞控制"><a href="#如何进行拥塞控制" class="headerlink" title="如何进行拥塞控制"></a>如何进行拥塞控制</h1><p>在进行拥塞控制的过程中，常用的三种拥塞控制算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免算法</li>
<li>快重传和快恢复</li>
</ul>
<h1 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h1><h2 id="拥塞窗口的增长"><a href="#拥塞窗口的增长" class="headerlink" title="拥塞窗口的增长"></a>拥塞窗口的增长</h2><p>当一条TCP连接开始时，cwnd的值通常被设置为1个MSS。在慢启动的状态下，cwnd的值以1个MSS开始并且每个传输的报文段被确认就将cwnd的值翻倍。比如TCP向网络中发送的第一个报文段并且得到了确认。TCP的cwnd的值增加到：2个MSS，这样它就可以发送两个最长长度的报文段。如果这两个报文段都被确认了，则发送方对每个确认报文段都将拥塞窗口增加一个MSS，使得拥塞窗口的值变为：4个MSS。如此重复，在慢启动的状态下，cwnd以指数增长</p>
<h2 id="结束慢启动的方式（下面介绍的Reno版TCP，如果是：Tahoe版TCP，没有快速重传和快速恢复）"><a href="#结束慢启动的方式（下面介绍的Reno版TCP，如果是：Tahoe版TCP，没有快速重传和快速恢复）" class="headerlink" title="结束慢启动的方式（下面介绍的Reno版TCP，如果是：Tahoe版TCP，没有快速重传和快速恢复）"></a>结束慢启动的方式（下面介绍的Reno版TCP，如果是：Tahoe版TCP，没有快速重传和快速恢复）</h2><h3 id="出现了超时，进入拥塞避免状态"><a href="#出现了超时，进入拥塞避免状态" class="headerlink" title="出现了超时，进入拥塞避免状态"></a>出现了超时，进入拥塞避免状态</h3><p>当TCP在传输报文中，出现了第一次超时时，马上启动一个状态变量：ssthresh，并且把它设置为cwnd/2，同时发送方会马上把cwnd从重新设置为：1个MSS，并重新开始慢启动过程。ssthresh是慢启动的阈值。cwnd在慢启动的状态呈指数增长，<strong>当cwnd的值超过或等于ssthresh时，不能在盲目的将cwnd翻倍了，而是进入拥塞避免状态，更为谨慎的增加cwnd的值</strong></p>
<h3 id="收到了3个冗余的ACK后，进入快重传和快恢复状态"><a href="#收到了3个冗余的ACK后，进入快重传和快恢复状态" class="headerlink" title="收到了3个冗余的ACK后，进入快重传和快恢复状态"></a>收到了3个冗余的ACK后，进入快重传和快恢复状态</h3><p>如果发送方检测到了3个冗余的ACK后，<strong>这时TCP将cwnd的值减半，ssthresh的值也被更新为减半后的cwnd的值，然后，cwnd的值再加上3个MSS，最后，执行快速重传并进入快速恢复的状态。</strong></p>
<h1 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h1><p>一旦进入了拥塞避免状态，cwnd的值将在一个RTT时间内只增加1个MSS。cwnd的值呈线性增长。</p>
<ul>
<li>在拥塞避免状态下，如果遇到了超时，TCP也会把状态变量：ssthresh的值设置为：cwnd/2,然后，把cwnd设置为1个MSS，并且进入慢启动状态。</li>
<li>在拥塞避免状态下，如果是检测到了3个冗余的ACK后，这时TCP将cwnd的值减半，ssthresh的值也被更新为减半后的cwnd的值，然后，cwnd的值再加上3个MSS，最后，执行快速重传并进入快速恢复的状态。<br>如下图，为超时的模拟图：<br><img src="http://i4.buimg.com/593129/4925cdb62926af3d.png" alt="image"></li>
</ul>
<h1 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h1><p>当发送方检测到了3个冗余的ACK后，将会马上重传丢失的分组，并且会执行快速恢复的算法。此时，cwnd的值是比原来的cwnd的值还多了3个的MSS后，它又会进入拥塞避免状态。如下图所示：<br><img src="http://i2.muimg.com/593129/f3e6140d0db9556e.png" alt="image"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TCP的拥塞控制在当前的网络传输中是占有很大地位的，因为它可以动态的调节发送方的传输效率，从而也间接的保证了TCP报文的可靠的传输。</p>
]]></content>
      
        
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP流量控制]]></title>
      <url>/2017/05/05/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="为什么要进行流量的控制"><a href="#为什么要进行流量的控制" class="headerlink" title="为什么要进行流量的控制"></a>为什么要进行流量的控制</h1><p>在实际的TCP报文段传输的过程中，可能会出现发送方的发送速率大于接收方的应用程序的读取速率，因此会出现接收缓存被使用完的情况，所以需要流量控制来进行速度匹配工作。TCP的流量控制可以通过滑动窗口协议来实现。</p>
<h1 id="如何进行流量控制"><a href="#如何进行流量控制" class="headerlink" title="如何进行流量控制"></a>如何进行流量控制</h1><p>在给发送方返回ACK报文段的时候，我们都会在该报文段中的接收窗口字段中加入接收方的接收缓存当前还可以接收的数据的大小。如果接收窗口为0时，发送方不能再发送数据了。此时，接收方的应用程序会不断的从接收缓存中读取数据，但是由于接收缓存中腾空的空间太小，接收方必须要在缓存中的空间足够多时，才向发送方发送一个额外的确认报文，通知发送方可以继续发送数据了（这里是考虑到传输效率的问题，本文后面会讨论）。</p>
<h1 id="问题考虑：如果额外的确认报文丢失了怎么办？"><a href="#问题考虑：如果额外的确认报文丢失了怎么办？" class="headerlink" title="问题考虑：如果额外的确认报文丢失了怎么办？"></a>问题考虑：如果额外的确认报文丢失了怎么办？</h1><p>我们的发送方一直在等接收方的额外的确认报文的到来，如果该报文在传输过程中丢失了，则发送方就会无休止的在等待接收方的通知，从而会进入一个死锁。为了消除这个现象，TCP协议设置了一个：坚持定时器。其工作流程如下：（参考博客：<a href="http://www.itdadao.com/articles/c15a615438p0.html" target="_blank" rel="noopener">TCP坚持定时器</a>）</p>
<ul>
<li>发送端收到0窗口通告后，就启动坚持定时器，并在定时器溢出的时候向客户端查询窗口是否已经增大。</li>
<li>在定时器未到，就收到非零通告，则关闭该定时器，并发送数据。</li>
<li>若定时器已到，还没有收到非零通告，就发探查报文。</li>
<li>如果探查报文ACK的通告窗口为0，就将坚持定时器的值加倍，TCP的坚持定时器使用1，2，4，8，16……64秒这样的普通指数退避序列来作为每一次的溢出时间，重复1、2、3步，如果通告窗口非零，发送数据，关闭定时器。</li>
</ul>
<h1 id="传输效率问题"><a href="#传输效率问题" class="headerlink" title="传输效率问题"></a>传输效率问题</h1><h2 id="发送端的问题"><a href="#发送端的问题" class="headerlink" title="发送端的问题"></a>发送端的问题</h2><p>有这样的一个应用程序（如：telnet应用），它可能一次只产生一个字节的数据。这样我们的发送端可能生成一个41字节的数据报，然后传输该数据报。一个次传输只能传输一个字节的数据，它不但传输效率低下，而且还会带来其他不好的影响如：造成网络拥塞等。</p>
<p>解决方法是：迫使发送端收集数据，然后，发送一个较大的数据块。发送端的TCP要等待多长时间了？如果它等待过长，它就会使整个的过程产生较长的时延。如果它的等待时间不够长，它就可能发送较小的报文段，于是，Nagle找到了一个很好的解决方法，发明了Nagle算法。而他选择的等待时间是一个RTT,即下个ACK来到时。</p>
<h3 id="解决办法：Nagle算法（针对小分组）："><a href="#解决办法：Nagle算法（针对小分组）：" class="headerlink" title="解决办法：Nagle算法（针对小分组）："></a>解决办法：Nagle算法（针对小分组）：</h3><ul>
<li>若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起 来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一 个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。</li>
<li>如果缓存中的数据字节数达到了发送窗口的1/2或接近最大报文段长度MSS时，立即将它作为一个报文段发送。（防止报文段太长，在IP中被分片传输）</li>
</ul>
<h2 id="接收端的问题"><a href="#接收端的问题" class="headerlink" title="接收端的问题"></a>接收端的问题</h2><p>接收端的TCP可能产生<strong>糊涂窗口综合征</strong>。接收方的应用程序消耗数据比较慢，当接收缓存满了，发送方会停止发送数据，而当接收端的应用程序从接收缓存中读取一个字节的数据后，接收端的TCP宣布其窗口大小为1字节。那么发送端就会向其发送一个包含一个字节数据的数据报。这样，问题又回到了发送端，每次发送一个字节的效率太低了，但是我接收缓存就只有一个字节的空间啊。所以解决问题的关键还在接收端上。</p>
<h3 id="解决办法：Clark解决方法"><a href="#解决办法：Clark解决方法" class="headerlink" title="解决办法：Clark解决方法"></a>解决办法：Clark解决方法</h3><p>Clark解决方法是只要有数据到达就发送确认，但宣布的窗口大小为零后，直到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了，才会向发送端发送一个特殊的确认报文。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TCP流量控制是通过滑动窗口来实现，最主要的一个步骤就是：坚持定时器和接收端发送的那个特殊的确认报文。在控制流量的同时也同时可以控制程序的传输效率。</p>
]]></content>
      
        
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP数据报丢失原因（介绍校验和的计算）]]></title>
      <url>/2017/05/05/TCP%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%A2%E5%A4%B1%E5%8E%9F%E5%9B%A0%EF%BC%88%E4%BB%8B%E7%BB%8D%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%9A%84%E8%AE%A1%E7%AE%97%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="数据报丢失的原因"><a href="#数据报丢失的原因" class="headerlink" title="数据报丢失的原因"></a>数据报丢失的原因</h1><ul>
<li>交换机或路由器过载使TCP包或确认包丢失；</li>
<li>接收端对TCP包的确认速度慢，致使发送端超时重发；</li>
<li>接收端缓存溢出；</li>
<li>TCP数据包在传输过程中丢失或损坏；</li>
<li>发送端与接收端之间的距离太远或传输速度太慢</li>
</ul>
<h1 id="如何检验TCP报文段是否损坏"><a href="#如何检验TCP报文段是否损坏" class="headerlink" title="如何检验TCP报文段是否损坏"></a>如何检验TCP报文段是否损坏</h1><p>TCP报文结构中有一个校验和字段，我们在生成一个TCP报文的时候，需要通过一定的方法计算出该报文校验和字段的值，它的方法如下：</p>
<ul>
<li>首先，我们要加入12字节的伪报文到TCP报文段的头部</li>
<li>把校验和字段置为0；</li>
<li>把整个TCP数据报（包括伪报头+TCP报文首部+数据）所有位划分为16位（2字节）的字</li>
<li>把所有16位的字相加，如果遇到进位，则将<strong>高于16字节的进位部分的值加到最低位上</strong>，举例，0xBB5E+0xFCED=0x1 B84B，则将1放到最低位，得到结果是0xB84C</li>
<li>将所有字相加得到的结果应该为一个16位的数，将该数<strong>取反</strong>则可以得到检验和。并且把加入的伪报头删除。</li>
</ul>
<h1 id="什么是伪报头"><a href="#什么是伪报头" class="headerlink" title="什么是伪报头"></a>什么是伪报头</h1><p>伪报头包含IP首部一些字段。其目的是让TCP两次检查数据是否已经正确到达目的地，只是单纯为了做校验用的。计算完校验和后，要把伪报头删除<br><img src="http://i2.muimg.com/593129/5f65885bd84320e5.png" alt="image"></p>
<h1 id="如何使用校验和，判断报文是否损坏"><a href="#如何使用校验和，判断报文是否损坏" class="headerlink" title="如何使用校验和，判断报文是否损坏"></a>如何使用校验和，判断报文是否损坏</h1><p>在接收端，同样是为TCP报文段加入伪报头。然后，把整个TCP数据报（包括伪报头+TCP报文首部+数据）所有位划分为16位（2字节）的字。把所有16位的字相加，如果得到的16位二进制数为全1，说明没有出错。只要这中间出现一个0，就说明TCP报文段被损坏了，则它会被丢弃。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇博客主要介绍TCP报文丢失的原因以及报文是否被损坏的检测方法。如果还是不明白如何计算校验和，可以查看《计算机网络-自顶向下》的135页的UDP校验和的计算。UDP的校验和和TCP的校验和计算是一模一样的，原理也是一模一样的。</p>
]]></content>
      
        
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP重传机制]]></title>
      <url>/2017/05/05/TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="重传方式"><a href="#重传方式" class="headerlink" title="重传方式"></a>重传方式</h1><ul>
<li>回退方式</li>
<li>选择重传</li>
</ul>
<h1 id="什么时候要重传了？"><a href="#什么时候要重传了？" class="headerlink" title="什么时候要重传了？"></a>什么时候要重传了？</h1><ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<h1 id="回退方式"><a href="#回退方式" class="headerlink" title="回退方式"></a>回退方式</h1><p>如果采用回退方式处理接收到的不连续的字节流，它会把丢失那个序号以后的字节数据全部重传，不管之后的数据是否成功接收。</p>
<h1 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h1><p>当出现需要重传时候，只需要在重传队列中寻找那些未传输成功是数据，然后，重新传输那些丢失的数据。</p>
<h1 id="超时重传介绍"><a href="#超时重传介绍" class="headerlink" title="超时重传介绍"></a>超时重传介绍</h1><p>超时重传需要一个辅助的工具：重传定时器。当发送方把一个TCP报文段交给了网络层后，首先将该报文的副本放入到重传队列中，同时启动一个重传定时器。该重传定时器会被设定一个初值，然后，开始倒计时，如果在重传定时器的值为0时，还没有收到该报文段的确认报文，则会准备重传该报文。</p>
<h1 id="重传定时器值的设置"><a href="#重传定时器值的设置" class="headerlink" title="重传定时器值的设置"></a>重传定时器值的设置</h1><p>我们把重传定时器的值称为：RTO（Retransmission TimeOut）；而为确定RTO，我们还需要一个参考值，它就是RTT（数据报发送和确认信息的往返时间）。如果发生了超时重传，我们把RTO=i X RTT，其中i为一个大于1的正整数，在《计算机网络：自顶向下》的第165页就是把i设置为：2。如果没有发生数据报丢失的话，那么我们也要更新该TCP连接的RTT的值，公式为：RTT=j X 旧RTT+(1-j) *最新测量的RTT 。因为在网络的环境是千变万化的，所以我们需要不断的更新RTT以适应新的的网络环境，j在[RFC 6289]中的给出的参考值是：0.125。</p>
<h1 id="为啥：RTO-i-RTT"><a href="#为啥：RTO-i-RTT" class="headerlink" title="为啥：RTO=i * RTT"></a>为啥：RTO=i * RTT</h1><p>在出现超时的时候，我们需要重传数据并且会重启重传定时器，该定时器的值会被设置为：RTO。那为啥不能像设置普通重传计时器一样，设置为最新的RTT了？这个主要是因为定时器过期很可能由于网络拥塞引起的，造成分组丢失或长时间排队时延。所以如果源总是在很短的时间内，持续的重发分组，会让拥塞加剧。</p>
<p>最大重传次数取决于发送操作系统的配置值。默认情况下，Windows主机默认重传5次。大多数Linux系统默认最大15次。两种操作系统都可配置。</p>
<h1 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h1><p>超时重传有一个最大的缺点就是超时周期可能相对较长。当一个报文丢失后，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端的时延。幸运的是，发送方可在超时之前通过注意是否出现了冗余ACK来较好的检测是否发送了丢包。</p>
<h1 id="什么是冗余ACK"><a href="#什么是冗余ACK" class="headerlink" title="什么是冗余ACK"></a>什么是冗余ACK</h1><p>因为TCP不使用否认确认，所以接收方不能向发送方发回一个显示的否认确认，它只对已经成功接收的最后一个按序字节数据进行重复确认。发送方收到的多余的对某个序列的确认报文，我们就叫多余的ACK为冗余的ACK，如果冗余ACK的数量达到了三个（换句话说，就是发送方收到了四个同样的ACK报文）。这个时候就会启动快速重传机制，对丢失的报文进行重传。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>重传机制是TCP可靠传输的一个保障机制。超时重传机制和快速重传机制在一个系统是同时存在，其中快速重传和快速恢复，会应用在拥塞控制中，这个将会在后续介绍</p>
]]></content>
      
        
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP滑动窗口协议]]></title>
      <url>/2017/05/05/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h1 id="理解滑动窗口，先了解下面四个小知识"><a href="#理解滑动窗口，先了解下面四个小知识" class="headerlink" title="理解滑动窗口，先了解下面四个小知识"></a>理解滑动窗口，先了解下面四个小知识</h1><ul>
<li>TCP使用两个缓存和两个窗口控制字节流的传输过程。发送方有一个发送缓存，用了存储进程准备发送的数据。接收方有一个接收缓存，用来存储接收成功的数据，等待接收方应用程序读取。接收方通过接收缓存的空余空间，计算出接收窗口的大小，并且会通过应答报文告知发送方。发送方也有一个发送窗口，只要这个窗口不为0，发送方就可以发送数据。</li>
<li>TCP不可能为对每个字节都进行确认，而是采用累积确认的方式对发送的数据进行确认。如果发送方收到ACK报文中的确认序号为：522，则表示编号为521号之前的数据都已经被成功接收，下面开始接收编号522之后的数据了。</li>
<li>每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送</li>
<li>每个窗口用三个指针表示，第一个指向窗口的第一个字节，第二个指向窗口中马上要发送的字节，第三个指向窗口的最后一个字节。</li>
</ul>
<h1 id="传输字节的状态分类"><a href="#传输字节的状态分类" class="headerlink" title="传输字节的状态分类"></a>传输字节的状态分类</h1><ul>
<li>已经成功发送的</li>
<li>已经发送，还没有收到确认报文的</li>
<li>准备发送的数据</li>
<li>还没准备发送的数据。</li>
</ul>
<h1 id="滑动窗口移动样例（参考博客：滑动窗口介绍）"><a href="#滑动窗口移动样例（参考博客：滑动窗口介绍）" class="headerlink" title="滑动窗口移动样例（参考博客：滑动窗口介绍）"></a>滑动窗口移动样例（参考博客：<a href="http://www.cnblogs.com/woaiyy/p/3554182.html" target="_blank" rel="noopener">滑动窗口介绍</a>）</h1><p>TCP建立连接的初始，B会告诉A自己的接收窗口大小，比如为‘20’：<br>字节31-50为发送窗口<br><img src="http://i2.muimg.com/593129/50b0987ef1b368c2.png" alt="image"></p>
<p>A发送11个字节后，发送窗口位置不变，B接收到了乱序的数据分组：<br><img src="http://i2.muimg.com/593129/9210cc33891a60ee.png" alt="image"></p>
<p>只有当A成功发送了数据，即发送的数据得到了B的确认之后，才会移动滑动窗口离开已发送的数据；同时B则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递。<br>如果，中途那些乱序的数剧在重传定时器所规定的时间内都没有收到ACK报文段的话，A就会重传报文，至于，重传的机制有：</p>
<ul>
<li>选择重传</li>
<li>回退N步<br>这两个重传机制，我们将在后续的博客中介绍。最大重传次数取决于发送操作系统的配置值。默认情况下，Windows主机默认重传5次。大多数Linux系统默认最大15次。两种操作系统都可配置。</li>
</ul>
<h1 id="数据报丢失的原因"><a href="#数据报丢失的原因" class="headerlink" title="数据报丢失的原因"></a>数据报丢失的原因</h1><ul>
<li>交换机或路由器过载使TCP包或确认包丢失；</li>
<li>接收端对TCP包的确认速度慢，致使发送端超时重发；</li>
<li>接收端缓存溢出；</li>
<li>TCP数据包在传输过程中丢失或损坏；</li>
<li>发送端与接收端之间的距离太远或传输速度太慢</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TCP协议使用以字节为单位的滑动窗口的协议来控制字节流的发送、接收、确认和重传过程，另外还可以用它来进行流量控制和拥塞控制。其实“滑动”的含义是指TCP进程在发送端有序的从发送缓存中提取数据并且发送给接收端，而接收端又通过接收缓存来间接控制发送端一次可以发送的数据量的大小。</p>
]]></content>
      
        
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP可靠的数据传输]]></title>
      <url>/2017/05/05/TCP%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</url>
      <content type="html"><![CDATA[<h1 id="TCP如何提供可靠的数据传输（参考资料：TCP如何提供可靠传输）"><a href="#TCP如何提供可靠的数据传输（参考资料：TCP如何提供可靠传输）" class="headerlink" title="TCP如何提供可靠的数据传输（参考资料：TCP如何提供可靠传输）"></a>TCP如何提供可靠的数据传输（参考资料：<a href="http://blog.csdn.net/jhh_move_on/article/details/45770087" target="_blank" rel="noopener">TCP如何提供可靠传输</a>）</h1><p>TCP的连接的建立是TCP进行可靠的数据传输的基础。后续在建立连接基础上，TCP又提供了如下技术保障数据的可靠的传输</p>
<ul>
<li>TCP根据MSS等数据，把需要传输的数据分割成TCP认为最合适的大小发送。</li>
<li>TCP在交付了其报文给网络层后，将启动一个重传定时器，如果在该TCP报文的确认报文不能及时到达，将会启动重传。（差错控制，确认重传）</li>
<li>当TCP数据报到达了目的后，会发送确认报文段给源主机。这个确认不是立即发送，通常将推迟几分之一秒 。（可能会先对报文进行校验）</li>
<li>校验出包有错，丢弃报文段，不给出响应，TCP发送数据端，超时时会重发数据</li>
<li>因为IP数据报的达到可能是无序的，所以我们的TCP报文段也可能是无序到达的，所以需要先对这无序的多个报文段排序后，才交付给应用层</li>
<li>如果收到的TCP报文段是重复的，将丢弃该重复的报文段</li>
<li>TCP提供的流量控制</li>
<li>TCP提供的拥塞控制</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述说的每个点都是TCP的重要知识点，后续的博客将会一一总结各个点中的重要知识，学习完上面的全部知识，那么TCP也就过关了。另外，差错控制、流量控制和拥塞控制都是要使用一个叫：滑动窗口协议的东西</p>
]]></content>
      
        
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP四次挥手]]></title>
      <url>/2017/05/03/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      <content type="html"><![CDATA[<h1 id="TCP的连接的断开"><a href="#TCP的连接的断开" class="headerlink" title="TCP的连接的断开"></a>TCP的连接的断开</h1><p>上次我们介绍了TCP的连接的建立需要经历“三次握手”。今天需要介绍的主题是TCP连接的断开，这个是比较复杂的一个事情，它需要经历我们常说的“四次挥手”。客户端进程和服务端进程都可以主动提出释放连接，在socket编程中，就是一方简单的调用close方法。</p>
<h1 id="TCP四次握手图示"><a href="#TCP四次握手图示" class="headerlink" title="TCP四次握手图示"></a>TCP四次握手图示</h1><p><img src="http://i1.piimg.com/593129/3aca8571239c31c4.jpg" alt="image"></p>
<h1 id="TCp四次握手详细介绍（假设客户端首先提出释放连接）"><a href="#TCp四次握手详细介绍（假设客户端首先提出释放连接）" class="headerlink" title="TCp四次握手详细介绍（假设客户端首先提出释放连接）"></a>TCp四次握手详细介绍（假设客户端首先提出释放连接）</h1><ul>
<li>客户端A发送一个“FIN”报文段给服务器B，其中该报文中的FIN标志位被置为1。</li>
<li>服务器B收到了FIN报文段后，它会向客户端发送“ACK”报文段，表示允许断开该TCP连接了。同时它还会通知高层应用程序，客户端已经请求释放连接。此时客户端已经不再会给服务器发送数据了，但是服务器到客户端的TCP连接还没有断开，所以服务器还是可以向客户端发送数据，此时状态称为“半关闭状态”。</li>
<li>当服务端的高层程序已经没有数据要发送了，它会通知TCP可以断开连接了，这时候，服务器就会向客户端发送FIN报文段。</li>
<li>客户端收到FIN报文段后，客户端会发送“ACK”报文段给服务器，同时客户端会进入一个叫“TIME-WAIT”的状态，需要再等待两个报文寿命（MSL）时间后，才进入最后的“CLOSE”状态。</li>
</ul>
<h1 id="分析：为什么要等待2个MSL后才关闭整个连接"><a href="#分析：为什么要等待2个MSL后才关闭整个连接" class="headerlink" title="分析：为什么要等待2个MSL后才关闭整个连接"></a>分析：为什么要等待2个MSL后才关闭整个连接</h1><p>确保服务器在最后阶段发送给客户端的数据，已经客户端发送给服务器的最后一个“ACK”报文能够正确地被接收，防止因个别传输错误导致连接释放失败。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>四次挥手比起三次握手是比较复杂的一个问题，但是对于我们理解了它的原理也就差不多了.现在我自己有一个疑问就是：第一次挥手后，说客户端已经不再会向服务器发送消息了，这个描述是否恰当，后续不是还要给服务器发送“ACK”报文吗？后来，自己悟出了其中语义，其实“ACK”报文段本来就是不含数据的，所以该说法也是恰当的。</p>
]]></content>
      
        
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[选择排序(包含堆排序)]]></title>
      <url>/2017/05/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>每一趟都从n-i+1（i=1,2,3….n-1）个记录中选择出最小的关键字，作为有序序列的第i个元素。</p>
<h1 id="常用的选择排序"><a href="#常用的选择排序" class="headerlink" title="常用的选择排序"></a>常用的选择排序</h1><ul>
<li>简单选择排序</li>
<li>堆排序</li>
</ul>
<h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><h2 id="思路-（参考：选择排序）"><a href="#思路-（参考：选择排序）" class="headerlink" title="思路 （参考：选择排序）"></a>思路 （参考：<a href="http://blog.csdn.net/u011784495/article/details/70985444" target="_blank" rel="noopener">选择排序</a>）</h2><p>数组A，长度为：n，临时变量：i,初始化为1</p>
<ul>
<li>从A[i]~A[n]这n-i+1个元素中，找出最小的关键字，并且记录其下标</li>
<li>如果该关键字不是A[i]~A[n]这个序列的第一个元素，则将该两个位置的元素替换</li>
<li>将i从1~n-1，递增循环执行上述两个步骤</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef int Datatype;    //编译期多态的一种：转换</span><br><span class="line"></span><br><span class="line">void print(Datatype * data, int i, int length) &#123;</span><br><span class="line">	int j = 0;</span><br><span class="line">	cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;趟排序：&quot;;</span><br><span class="line">	for (j = 0; j &lt; length; ++j) &#123;</span><br><span class="line">		cout &lt;&lt; data[j] &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void EasySelectSort(Datatype * data, const int length) &#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	int j = 0;</span><br><span class="line">	Datatype min;</span><br><span class="line">	int temp = 0;</span><br><span class="line">	for (i = 0; i &lt; length-1; ++i) &#123;    //只需要确认前length-1个元素的顺序，则最后一个位置的元素的位置也就确定了</span><br><span class="line">		temp = i;                       //记录temp</span><br><span class="line">		for (j=i; j &lt; length; ++j) &#123;    //找出最小的那个关键字的位置。 </span><br><span class="line">			if (data[j] &lt; data[temp]) &#123;</span><br><span class="line">				temp = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (temp != i) &#123;   //判断是否需要交换两个位置上的元素</span><br><span class="line">			min = data[temp];</span><br><span class="line">			data[temp] = data[i];</span><br><span class="line">			data[i] = min;</span><br><span class="line">		&#125;</span><br><span class="line">		print(data, i, length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">	int data[] = &#123; 7,4,-2,19,13,6 &#125;;</span><br><span class="line">	EasySelectSort(data, sizeof(data) / sizeof(int));</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="http://i4.buimg.com/593129/c94e7b5233e3a747.png" alt="image"></p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>我们通过分析可以知道，我们程序无论是什么情况，都要比较：n*(n-1)/2次。所以程序的时间复杂度为：O(n^2)。</p>
<h2 id="是否稳定"><a href="#是否稳定" class="headerlink" title="是否稳定"></a>是否稳定</h2><p>稳定的定义就是：两个相同的数，在排完序后前后的相对顺序没有改变。对于简单选择排序，它是不稳定的，我可以简单的举个例子：{7,7,2}，当我们进行简单选择排序后，第一个7会和2调换位置，从出现不稳定的情况</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>简单的选择排序为了得出有序的序列，对于任意序列都要比较：n*(n-1)/2次。那么我们要优化这个算法的话，那么就要减少我们的比较的次数。所以从比较这里出发：我们为得出n个关键字中的最小的值，需要比较n-1次，而下一次要得出n-1个关键字中最小的值时，同样又要比较n-2次，如果我们可以利用之前的n-1次的比较结果，那么我们就可能在下一次寻找中，减少比较次数，从而就可以提高程序的效率了。堆就可以记录这些信息，所以我们就提出了另外一种优化的选择排序：堆排序</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>用一个完全二叉树来表示堆，堆有两种：最大堆和最小堆。</p>
<ul>
<li>最大堆：所有结点都比它们的左右孩子大。调整过程出现两个孩子结点，都大于父结点，选择大的那个替换。</li>
<li>最小堆：所有结点都比它们的左右孩子小。调整过程出现两个孩子结点，都小于父结点，选择小的那个替换。</li>
</ul>
<p>堆排序的大体思路是（以最小堆为例）：</p>
<ul>
<li>首先建立初始堆</li>
<li>输出根结点，用最后一个结点替换根结点，删除最后一个结点，并且对堆进行调整，使其还是满足最小堆的性质。</li>
<li>重复，第二个过程，直到堆为空为止</li>
</ul>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>我们从思路分析，可以知道我们需要解决两个问题：</p>
<ul>
<li>建立初始堆</li>
<li>输出后，对堆的调整</li>
</ul>
<h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void HeapAdjust(Datatype * data, int length, int s) &#123;</span><br><span class="line">	//最小堆</span><br><span class="line">	int j = 0;</span><br><span class="line">	Datatype temp = data[s];</span><br><span class="line">	j = 2 * s + 1;</span><br><span class="line">	for (; j &lt;= length; j = 2 * j + 1) &#123;</span><br><span class="line">		/*</span><br><span class="line">		最大堆需要修改：下面两个if语句，</span><br><span class="line">		*/</span><br><span class="line">		//如果左子树小于右子树，则让右子树去和根结点比较</span><br><span class="line">		if (j &lt; length &amp;&amp; data[j] &gt; data[j + 1]) &#123;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		//此时已经满足最小堆了条件了，可以停止寻找了</span><br><span class="line">		if (temp &lt;= data[j]) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		//交换根结点和孩子结点的值</span><br><span class="line">		data[s] = data[j];</span><br><span class="line">		s = j;</span><br><span class="line">	&#125;</span><br><span class="line">	//最后，确定了我们那个关键需要存放的地方</span><br><span class="line">	data[s] = temp;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(Datatype * data, int length) &#123;</span><br><span class="line">	for (int i = (length / 2)-1; i &gt;= 0; --i) &#123;</span><br><span class="line">		HeapAdjust(data, length-1, i);</span><br><span class="line">	&#125;</span><br><span class="line">	int n = length - 1;</span><br><span class="line">	//这里我们只需要比较前length-1个数，最后一个数的值也就确定了</span><br><span class="line">	while (n &gt;= 1) &#123;</span><br><span class="line">		Datatype temp;</span><br><span class="line">		temp = data[0];</span><br><span class="line">		data[0] = data[n];</span><br><span class="line">		data[n] = temp;</span><br><span class="line">		cout &lt;&lt; temp &lt;&lt; &quot; &quot;;</span><br><span class="line">		--n;</span><br><span class="line">		HeapAdjust(data, n, 0);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; data[n];</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主函数中，调用上述的HeapSort函数，就可以进行堆排序了。</p>
<h2 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>这里的时间主要是花费在调用heapAdjust函数中，HeapAdjust函数最多做：⌈log2n⌉次调整，总共需要调用：(n/2）+(n-1)次HeapAdjust函数，所以该时间复杂度为：O（nlog2n）</p>
<h2 id="是否稳定-1"><a href="#是否稳定-1" class="headerlink" title="是否稳定"></a>是否稳定</h2><p>堆排序是不稳定的排序算法，比如有无序的序列：{3,27,36,27}，所以在输出3后，最后的那个27替换到了根节点，从这里就可以看出该算法是不稳定的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>堆排序的时间复杂也是为：O（nlog2n），而且是最多就是：O（nlog2n）。对于时间复杂同样是：O（nlog2n）的排序算法：快速排序和归并排序来说，它只是在最坏情况下是占优势的。具体可以参考：<br><a href="http://blog.csdn.net/morewindows/article/details/6967409" target="_blank" rel="noopener">堆和快排、归并的比较</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP三次握手]]></title>
      <url>/2017/05/02/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
      <content type="html"><![CDATA[<h1 id="为什么TCP需要建立连接"><a href="#为什么TCP需要建立连接" class="headerlink" title="为什么TCP需要建立连接"></a>为什么TCP需要建立连接</h1><p>其实很好理解这个问题，我们要发送东西给人家，那么肯定要先给人家打好招呼，这样对方才可以在收到东西之后给你反馈啊。</p>
<h1 id="如何建立TCP连接"><a href="#如何建立TCP连接" class="headerlink" title="如何建立TCP连接"></a>如何建立TCP连接</h1><p>TCP连接需要经过“三次握手”的过程，我们先给出这个过程的示意图，如下图所示：<br><img src="http://i1.piimg.com/1949/de921378c192dfb9.jpg" alt="TCP三次握手"></p>
<ol>
<li>第一步：客户端A中的一个TCP进程要与服务器B中的一个TCP进程建立连接，首先是A中的TCP进程向B中的TCP进程发送特殊的TCP报文段（标志位SYN被置1，因此该报文段也称为：SYN报文段）。另外，客户端会随机地选择一个初始序号（client_isn），并且将这个序号作为该报文段中的“序号”字段的值。</li>
<li>第二步：B收到SYN报文段后，会为TCP连接分配TCP缓存和变量，并向该客户TCP进程发送允许连接的报文段（这里会引起：SYN洪泛攻击）。该允许报文段包括了三个主要的数据：标志位SYN和ACK被置1，确认号字段被赋值为：client_isn+1,服务器也选择自己初始序号（server_isn）,并且把该初始序号放在允许报文段的序号字段。因此，允许报文段又称为：SYNACK报文段。</li>
<li>第三步：收到SYNACK报文段后，客户端也给该连接分配缓存和变量，并且还要发送一个确认报文段给服务器。这个报文段是建立连接发送的最后一个报文段，报文段中的ACK被置1，确认号为：server_isn+1，同时要注意：此时连接已经建立了，所以标志位SYN是被置为0的。OK，到这里TCP连接已经被建立了，可以进行数据传输了。</li>
</ol>
<h1 id="分析：为什么要“三次握手”，而不是两次或四次"><a href="#分析：为什么要“三次握手”，而不是两次或四次" class="headerlink" title="分析：为什么要“三次握手”，而不是两次或四次"></a>分析：为什么要“三次握手”，而不是两次或四次</h1><h2 id="为什么不是两次了，有两个原因"><a href="#为什么不是两次了，有两个原因" class="headerlink" title="为什么不是两次了，有两个原因"></a>为什么不是两次了，有两个原因</h2><ol>
<li>如果A向B请求连接，B同意了为此次连接分配了资源和变量，然后，会返回允许报文段给A，若B的应答没有到达A端，A认为连接未建立，而B认为建立了。B会在一段时间内保留分配的资源，如果大量A这样请求，B会崩溃（SYN洪泛攻击就是这个原理）。而“三次握手”的话，我们就可以知道这次连接是没有建立成功的。</li>
<li>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。这个主要是因为SYN报文段在传输过程中耽误了太久的时间，客户端A就以为丢失了，已经重新发送了SYN报文段，建立好了连接。但是我们的服务器B不知道这个事情，同样会为它分配资源，并且返回确认报文，但是客户端收到后，看到后不会去理会它，这样就会出现和第一种一样的情况，，A认为连接未建立，而B认为建立了。B会在一段时间内保留分配的资源，如果大量A这样请求，B会崩溃。</li>
</ol>
<h2 id="为什么不是四次"><a href="#为什么不是四次" class="headerlink" title="为什么不是四次"></a>为什么不是四次</h2><p>这个很容易解释，我们三次可以搞定的东西，为啥还要四次了。</p>
<h1 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用伪造的IP地址向被攻击者发送TCP连接请求，而被攻击者会为这些请求分配资源和变量并且会发送应答报文给发送者，但是这些报文永远都无法到达目的地。那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。如果攻击者发送大量的这样的TCP连接的话，就会造成服务器因为资源不够而崩溃。</p>
<h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><ol>
<li>降低SYN timeout时间，使得主机尽快释放半连接的占用</li>
<li>采用SYN cookie设置，如果短时间内连续收到某个IP的重复SYN请求，则认为受到了该IP的攻击，丢弃来自该IP的后续请求报文</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TCP的三次握手目的是同步连接双方的序列号确认号并交换 TCP 窗口信息。其中我们需要知道SYN和RST两个标志位都是和建立TCP连接有关的。</p>
]]></content>
      
        
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP报文段结构]]></title>
      <url>/2017/05/01/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h1><p>TCP是可靠的、面向连接、面向字节流、支持双工（客户端和服务器端可以互相传输数据）、支持并发连接、提供确认重传与拥塞控制的传输层协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">添加补充知识：</span><br><span class="line">UDP是一种无连接、不可靠、简单高效的一种面向报文传输的传输层协议。</span><br></pre></td></tr></table></figure>
<h1 id="TCP的报文段结构"><a href="#TCP的报文段结构" class="headerlink" title="TCP的报文段结构"></a>TCP的报文段结构</h1><p>TCP的报文段结构由报文首部和数据组成。其中报文段的首部的长度为：20字节~60字节。如下图所示，为TCP报文段的结构的展示图：<br><img src="http://i2.muimg.com/4851/fc96c5794f9ca199.png" alt="image"></p>
<p>下面我们，一一介绍各个主要的部分的含义：</p>
<ol>
<li>序号</li>
</ol>
<p>序号这个字段的长度为：32比特字，它表示的是我们发送那个数据中，第一个字节的字节流编号。</p>
<ol>
<li>确认号</li>
</ol>
<p>因为TCP提供的是累积确认，它的意思就是：如果我们得到的确认号为100，那么它就代表编号为99之前的字节流都已经被正确的接收了，现在我们要继续接收以编号为100的字节开头的报文段了。同时该字段的长度为：32比特字</p>
<ol>
<li>首部长度</li>
</ol>
<p>该字段主要是为了记录当前报文首部的长度。在介绍TCP的时候，我们已经说了TCP的报文首部的长度的范围是从20字节~ 60字节，另外我们的首都的长度又是以4字节为单位的，因此我们可以知道这个字段的取值为：5~15。同时该字段的长度为：4比特字</p>
<ol>
<li>保留</li>
</ol>
<p>保留的字段的长度为：6比特字，它是留作以后使用</p>
<ol>
<li>标志字段</li>
</ol>
<p>标志字段的长度为：6比特字</p>
<ul>
<li>ACK用于指示确认字段中的值有效，对报文段成功接收的进行确认</li>
<li>RST主要是用于服务器端向客户端发送特殊的重置报文，表示目的端口不可用</li>
<li>FIN是用于断开TCP连接</li>
<li>SYN是用于建立TCP连接</li>
<li>URG用于指示报文段存在着被发送端上层程序置为“紧急”的数据，配合紧急数据指针使用</li>
<li>PSH用于指示接收方立即将该数据交给上层</li>
</ul>
<p>其中PSH、URG和紧急数据指针在实践中并没有使用，可以不去了解。</p>
<ol>
<li>接收窗口</li>
</ol>
<p>接收窗口的长度为：16比特字。该窗口的大小是有发送端的接收缓存来决定的，它主要是用于流量控制和拥塞控制。窗口的值计算为：LastByteRcvd-LastByteRead&lt;=RcvBuffer。然后是：rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]</p>
<ol>
<li>检验和</li>
</ol>
<p>字段的长度为：16比特字。功能是用于检验当前的报文段是否有数据错误或丢失，具体的计算将在后续介绍。</p>
<ol>
<li>选项</li>
</ol>
<p>长度是从0-40字节之间，用于发送方和接收方协商最大的报文段长度（MSS）或高速网络环境下做窗口调节因子使用。</p>
<h1 id="知识点：MSS"><a href="#知识点：MSS" class="headerlink" title="知识点：MSS"></a>知识点：MSS</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>TCP协议中，我们把报文段数据部分的最大长度称为：MSS（最大段长度）。有个点需要注意的就是MSS的值不包括报文段的首部，同时其值和接收窗口无关。</p>
<h2 id="MSS值的选择的考虑因素"><a href="#MSS值的选择的考虑因素" class="headerlink" title="MSS值的选择的考虑因素"></a>MSS值的选择的考虑因素</h2><ul>
<li>协议开销：因为TCP报文段包括首部和数据两个部分，我们要让数据在整个报文段占有合理的比例</li>
<li>IP分段：如果MSS较大的话，则会受到IP分组的限制，较长的报文段会被IP分段传输，这样会增加网络开销和传输出错的概率</li>
<li>发送和接收缓存的限制：MSS的大小会直接影响发送和接收缓存的使用率</li>
<li>MSS默认值：</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上述部分的描述，我今天的对网络知识的学习也可以先到此为止。了解TCP报文段的结构是学习TCP的基础，我们的报文段最重要的部分就是：序号和确认号两个部分，它们是TCP可以提供可靠传输的基础。而接收窗口是TCP可以提供流量控制和拥塞控制的基础。</p>
]]></content>
      
        
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译期多态和运行期多态]]></title>
      <url>/2017/05/01/%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81/</url>
      <content type="html"><![CDATA[<h1 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h1><p>所谓的多态是通过一个单一的标识符支持不同的特定行为的能力。</p>
<h1 id="多态的分类"><a href="#多态的分类" class="headerlink" title="多态的分类"></a>多态的分类</h1><h2 id="从绑定时间"><a href="#从绑定时间" class="headerlink" title="从绑定时间"></a>从绑定时间</h2><ol>
<li>静态多态 （编译期多态）</li>
<li>动态多态 （运行期多态）</li>
</ol>
<h2 id="从表现的形式"><a href="#从表现的形式" class="headerlink" title="从表现的形式"></a>从表现的形式</h2><ol>
<li>虚函数</li>
<li>重载</li>
<li>模板 </li>
<li>转换 （类型别名）</li>
</ol>
<p>今天我们就只讨论从绑定时间来分的多态种类，即编译期多态和运行期多态。</p>
<h1 id="运行期多态"><a href="#运行期多态" class="headerlink" title="运行期多态"></a>运行期多态</h1><p>运行期多态可以说只要学了c++的人都是知道的。因为运行期多态就是我通俗所说的多态，它的提出可以归结于类继承的思想的提出。对于相关功能的对象的集合，我们希望抽象出它们功能集合，在基类中声明为虚函数，然后再子类中去重写这些虚函数，以实现子类其特有的功能。</p>
<ul>
<li>代码示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">	//纯虚函数</span><br><span class="line">	virtual void call()=0;</span><br><span class="line">&#125;;</span><br><span class="line">class Dog :public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">	void call() &#123;//实现Dog类自己的call函数</span><br><span class="line">		cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cat :public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">	void call() &#123;//实现Cat类自己的call函数</span><br><span class="line">		cout &lt;&lt; &quot;cat&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Animal * dog = new Dog();</span><br><span class="line">	dog-&gt;call();</span><br><span class="line">	Animal * cat = new Cat();</span><br><span class="line">	cat-&gt;call();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog</span><br><span class="line">cat</span><br></pre></td></tr></table></figure>
<p>所以，从上面这个程序我们也看出了多态的在运行期的实现方式。而其大体的原理就是在运行过程中，我们可以确定每个Animal对象内存中存放虚函数表的内容，从而可以调用正确的函数。而具体实现可以去查找虚函数的实现原理。</p>
<h1 id="编译期多态"><a href="#编译期多态" class="headerlink" title="编译期多态"></a>编译期多态</h1><p>编译期多态的主要是有两种：函数重载和模板。下面我们一一来介绍一番。</p>
<h2 id="函数重载的多态"><a href="#函数重载的多态" class="headerlink" title="函数重载的多态"></a>函数重载的多态</h2><p>所谓的函数重载，就是具有相同的函数名但是有不同参数列表（参数列表包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同）的函数，我们叫他们为函数重载。函数重载可以在编译时候就确定我们应该调用哪个函数，所谓我们称之为编译期的多态。</p>
<hr>
<h2 id="不过函数重载有一个美中不足之处就是不能为返回值不同的函数进行重载。那是因为人们常常不为函数调用指出返回值。并不是技术上不能通过返回值来进行重载。"><a href="#不过函数重载有一个美中不足之处就是不能为返回值不同的函数进行重载。那是因为人们常常不为函数调用指出返回值。并不是技术上不能通过返回值来进行重载。" class="headerlink" title="不过函数重载有一个美中不足之处就是不能为返回值不同的函数进行重载。那是因为人们常常不为函数调用指出返回值。并不是技术上不能通过返回值来进行重载。"></a>不过函数重载有一个美中不足之处就是不能为返回值不同的函数进行重载。那是因为人们常常不为函数调用指出返回值。并不是技术上不能通过返回值来进行重载。</h2><h2 id="模板的多态"><a href="#模板的多态" class="headerlink" title="模板的多态"></a>模板的多态</h2><p>模板是c++泛型编程的一大利器，真是因为有它的存在，我们才可以很好的编写出大量的泛型程序。例如容器等。下面我们给出模板的多态的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Dog&#123;</span><br><span class="line">public:</span><br><span class="line">	void call() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;Dog&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Cat&#123;</span><br><span class="line">public:</span><br><span class="line">	void call() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;cat&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void call(T &amp; t) &#123;</span><br><span class="line">	t.call();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Dog dog;</span><br><span class="line">	Cat cat;</span><br><span class="line">	call(dog);</span><br><span class="line">	call(cat);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog</span><br><span class="line">cat</span><br></pre></td></tr></table></figure>
<p>从上述的程序，我们定义了模板函数在编译期就已经确定了T的数据类型，所以我们就可以正确的调用恰当的函数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇博客，只是简单了介绍了编译期多态和运行期多态的知识，而我们除了需要知道这些只是外，我们还需要明白这两种实现机制所带来的效率问题。具体的探讨可以参考如下博客：</p>
<ul>
<li><a href="http://sourcedb.ict.cas.cn/cn/ictthesis/200907/P020090722599150915696.pdf" target="_blank" rel="noopener">C++的动态多态和静态多态</a></li>
<li><a href="http://www.cnblogs.com/QG-whz/p/5132745.html" target="_blank" rel="noopener">C++编译期多态与运行期多态</a></li>
</ul>
<p>最后，我再强调两个知识点：</p>
<ul>
<li>函数重载：返回值和函数名相同。参数类型和参数个数可以不同</li>
<li>函数重写：是在子类中对父类函数进行重新定义的过程。但是需要注意下面几个要点：</li>
</ul>
<ol>
<li>被重写的函数不能是static的。必须是virtual的，或者是override的(即函数在最原始的基类中被声明为virtual，c++中没有override)。</li>
<li>重写函数必须有相同的类型，名称和参数列表</li>
<li>重写函数的访问修饰符可以不同。尽管virtual是private的，派生类中重写改写为public,protected也是可以的（这点与C#完全不同）</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> c++提高 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
